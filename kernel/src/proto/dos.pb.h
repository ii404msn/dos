// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dos.proto

#ifndef PROTOBUF_dos_2eproto__INCLUDED
#define PROTOBUF_dos_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace dos {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_dos_2eproto();
void protobuf_AssignDesc_dos_2eproto();
void protobuf_ShutdownFile_dos_2eproto();

class User;
class Group;
class Cpu;
class Memory;
class Range;
class Port;
class Network;
class DiskIO;
class Resource;
class Process;
class Platform;
class Root;
class Mount;
class Device;
class NodeMeta;
class Container;
class PodSpec;
class JobSpec;
class JobStatus;
class PodLog;
class PodStatus;
class NodeStatus;
class ContainerLog;
class ContainerStatus;

enum RpcStatus {
  kRpcOk = 0,
  kRpcPrepareRootfsFailed = 1,
  kRpcNameExist = 2,
  kRpcError = 3,
  kRpcNotFound = 4,
  kRpcNoResource = 5
};
bool RpcStatus_IsValid(int value);
const RpcStatus RpcStatus_MIN = kRpcOk;
const RpcStatus RpcStatus_MAX = kRpcNoResource;
const int RpcStatus_ARRAYSIZE = RpcStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpcStatus_descriptor();
inline const ::std::string& RpcStatus_Name(RpcStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpcStatus_descriptor(), value);
}
inline bool RpcStatus_Parse(
    const ::std::string& name, RpcStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpcStatus>(
    RpcStatus_descriptor(), name, value);
}
enum NodeState {
  kNodeNormal = 0,
  kNodeOffline = 1,
  kNodeFrozen = 2
};
bool NodeState_IsValid(int value);
const NodeState NodeState_MIN = kNodeNormal;
const NodeState NodeState_MAX = kNodeFrozen;
const int NodeState_ARRAYSIZE = NodeState_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeState_descriptor();
inline const ::std::string& NodeState_Name(NodeState value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeState_descriptor(), value);
}
inline bool NodeState_Parse(
    const ::std::string& name, NodeState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeState>(
    NodeState_descriptor(), name, value);
}
enum ContainerType {
  kSystem = 0,
  kDocker = 1,
  kOci = 2
};
bool ContainerType_IsValid(int value);
const ContainerType ContainerType_MIN = kSystem;
const ContainerType ContainerType_MAX = kOci;
const int ContainerType_ARRAYSIZE = ContainerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContainerType_descriptor();
inline const ::std::string& ContainerType_Name(ContainerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContainerType_descriptor(), value);
}
inline bool ContainerType_Parse(
    const ::std::string& name, ContainerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContainerType>(
    ContainerType_descriptor(), name, value);
}
enum RestartStrategy {
  kNever = 0,
  kTenTimesPerHour = 10,
  kTwentyTimesPerHour = 20,
  kAlways = 1000
};
bool RestartStrategy_IsValid(int value);
const RestartStrategy RestartStrategy_MIN = kNever;
const RestartStrategy RestartStrategy_MAX = kAlways;
const int RestartStrategy_ARRAYSIZE = RestartStrategy_MAX + 1;

const ::google::protobuf::EnumDescriptor* RestartStrategy_descriptor();
inline const ::std::string& RestartStrategy_Name(RestartStrategy value) {
  return ::google::protobuf::internal::NameOfEnum(
    RestartStrategy_descriptor(), value);
}
inline bool RestartStrategy_Parse(
    const ::std::string& name, RestartStrategy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RestartStrategy>(
    RestartStrategy_descriptor(), name, value);
}
enum PodType {
  kPodBesteffort = 0,
  kPodBatch = 30,
  kPodLongrun = 60,
  kPodSystem = 80
};
bool PodType_IsValid(int value);
const PodType PodType_MIN = kPodBesteffort;
const PodType PodType_MAX = kPodSystem;
const int PodType_ARRAYSIZE = PodType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PodType_descriptor();
inline const ::std::string& PodType_Name(PodType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PodType_descriptor(), value);
}
inline bool PodType_Parse(
    const ::std::string& name, PodType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PodType>(
    PodType_descriptor(), name, value);
}
enum JobState {
  kJobNormal = 0,
  kJobRemoved = 1
};
bool JobState_IsValid(int value);
const JobState JobState_MIN = kJobNormal;
const JobState JobState_MAX = kJobRemoved;
const int JobState_ARRAYSIZE = JobState_MAX + 1;

const ::google::protobuf::EnumDescriptor* JobState_descriptor();
inline const ::std::string& JobState_Name(JobState value) {
  return ::google::protobuf::internal::NameOfEnum(
    JobState_descriptor(), value);
}
inline bool JobState_Parse(
    const ::std::string& name, JobState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<JobState>(
    JobState_descriptor(), name, value);
}
enum PodSchedStage {
  kPodSchedStagePending = 0,
  kPodSchedStageRunning = 1,
  kPodSchedStageDeath = 2,
  kPodSchedStageRemoved = 3
};
bool PodSchedStage_IsValid(int value);
const PodSchedStage PodSchedStage_MIN = kPodSchedStagePending;
const PodSchedStage PodSchedStage_MAX = kPodSchedStageRemoved;
const int PodSchedStage_ARRAYSIZE = PodSchedStage_MAX + 1;

const ::google::protobuf::EnumDescriptor* PodSchedStage_descriptor();
inline const ::std::string& PodSchedStage_Name(PodSchedStage value) {
  return ::google::protobuf::internal::NameOfEnum(
    PodSchedStage_descriptor(), value);
}
inline bool PodSchedStage_Parse(
    const ::std::string& name, PodSchedStage* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PodSchedStage>(
    PodSchedStage_descriptor(), name, value);
}
enum PodState {
  kPodPending = 0,
  kPodDeploying = 1,
  kPodRunning = 2,
  kPodDeath = 3
};
bool PodState_IsValid(int value);
const PodState PodState_MIN = kPodPending;
const PodState PodState_MAX = kPodDeath;
const int PodState_ARRAYSIZE = PodState_MAX + 1;

const ::google::protobuf::EnumDescriptor* PodState_descriptor();
inline const ::std::string& PodState_Name(PodState value) {
  return ::google::protobuf::internal::NameOfEnum(
    PodState_descriptor(), value);
}
inline bool PodState_Parse(
    const ::std::string& name, PodState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PodState>(
    PodState_descriptor(), name, value);
}
enum ContainerState {
  kContainerPending = 0,
  kContainerPulling = 1,
  kContainerBooting = 2,
  kContainerRunning = 3,
  kContainerCompleted = 4,
  kContainerKilled = 5,
  kContainerReserving = 6,
  kContainerError = 7
};
bool ContainerState_IsValid(int value);
const ContainerState ContainerState_MIN = kContainerPending;
const ContainerState ContainerState_MAX = kContainerError;
const int ContainerState_ARRAYSIZE = ContainerState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContainerState_descriptor();
inline const ::std::string& ContainerState_Name(ContainerState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContainerState_descriptor(), value);
}
inline bool ContainerState_Parse(
    const ::std::string& name, ContainerState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContainerState>(
    ContainerState_descriptor(), name, value);
}
enum HealthState {
  kUnCalculated = 0,
  kGood = 10,
  kSubHealth = 30,
  kUnHealth = 40
};
bool HealthState_IsValid(int value);
const HealthState HealthState_MIN = kUnCalculated;
const HealthState HealthState_MAX = kUnHealth;
const int HealthState_ARRAYSIZE = HealthState_MAX + 1;

const ::google::protobuf::EnumDescriptor* HealthState_descriptor();
inline const ::std::string& HealthState_Name(HealthState value) {
  return ::google::protobuf::internal::NameOfEnum(
    HealthState_descriptor(), value);
}
inline bool HealthState_Parse(
    const ::std::string& name, HealthState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HealthState>(
    HealthState_descriptor(), name, value);
}
// ===================================================================

class User : public ::google::protobuf::Message {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();

  void Swap(User* other);

  // implements Message ----------------------------------------------

  User* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 gid = 3;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 3;
  inline ::google::protobuf::int32 gid() const;
  inline void set_gid(::google::protobuf::int32 value);

  // optional uint64 ctime = 4;
  inline bool has_ctime() const;
  inline void clear_ctime();
  static const int kCtimeFieldNumber = 4;
  inline ::google::protobuf::uint64 ctime() const;
  inline void set_ctime(::google::protobuf::uint64 value);

  // optional string home = 5;
  inline bool has_home() const;
  inline void clear_home();
  static const int kHomeFieldNumber = 5;
  inline const ::std::string& home() const;
  inline void set_home(const ::std::string& value);
  inline void set_home(const char* value);
  inline void set_home(const char* value, size_t size);
  inline ::std::string* mutable_home();
  inline ::std::string* release_home();
  inline void set_allocated_home(::std::string* home);

  // @@protoc_insertion_point(class_scope:dos.User)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_ctime();
  inline void clear_has_ctime();
  inline void set_has_home();
  inline void clear_has_home();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 gid_;
  ::google::protobuf::uint64 ctime_;
  ::std::string* home_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static User* default_instance_;
};
// -------------------------------------------------------------------

class Group : public ::google::protobuf::Message {
 public:
  Group();
  virtual ~Group();

  Group(const Group& from);

  inline Group& operator=(const Group& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Group& default_instance();

  void Swap(Group* other);

  // implements Message ----------------------------------------------

  Group* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Group& from);
  void MergeFrom(const Group& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::int32 gid() const;
  inline void set_gid(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint64 ctime = 3;
  inline bool has_ctime() const;
  inline void clear_ctime();
  static const int kCtimeFieldNumber = 3;
  inline ::google::protobuf::uint64 ctime() const;
  inline void set_ctime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:dos.Group)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_ctime();
  inline void clear_has_ctime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint64 ctime_;
  ::google::protobuf::int32 gid_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static Group* default_instance_;
};
// -------------------------------------------------------------------

class Cpu : public ::google::protobuf::Message {
 public:
  Cpu();
  virtual ~Cpu();

  Cpu(const Cpu& from);

  inline Cpu& operator=(const Cpu& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cpu& default_instance();

  void Swap(Cpu* other);

  // implements Message ----------------------------------------------

  Cpu* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cpu& from);
  void MergeFrom(const Cpu& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 limit = 1;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 1;
  inline ::google::protobuf::uint64 limit() const;
  inline void set_limit(::google::protobuf::uint64 value);

  // optional uint64 share = 2;
  inline bool has_share() const;
  inline void clear_share();
  static const int kShareFieldNumber = 2;
  inline ::google::protobuf::uint64 share() const;
  inline void set_share(::google::protobuf::uint64 value);

  // optional uint64 used = 3;
  inline bool has_used() const;
  inline void clear_used();
  static const int kUsedFieldNumber = 3;
  inline ::google::protobuf::uint64 used() const;
  inline void set_used(::google::protobuf::uint64 value);

  // optional uint64 assigned = 4;
  inline bool has_assigned() const;
  inline void clear_assigned();
  static const int kAssignedFieldNumber = 4;
  inline ::google::protobuf::uint64 assigned() const;
  inline void set_assigned(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:dos.Cpu)
 private:
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_share();
  inline void clear_has_share();
  inline void set_has_used();
  inline void clear_has_used();
  inline void set_has_assigned();
  inline void clear_has_assigned();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 limit_;
  ::google::protobuf::uint64 share_;
  ::google::protobuf::uint64 used_;
  ::google::protobuf::uint64 assigned_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static Cpu* default_instance_;
};
// -------------------------------------------------------------------

class Memory : public ::google::protobuf::Message {
 public:
  Memory();
  virtual ~Memory();

  Memory(const Memory& from);

  inline Memory& operator=(const Memory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Memory& default_instance();

  void Swap(Memory* other);

  // implements Message ----------------------------------------------

  Memory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Memory& from);
  void MergeFrom(const Memory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 limit = 1;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 1;
  inline ::google::protobuf::uint64 limit() const;
  inline void set_limit(::google::protobuf::uint64 value);

  // optional uint64 used = 2;
  inline bool has_used() const;
  inline void clear_used();
  static const int kUsedFieldNumber = 2;
  inline ::google::protobuf::uint64 used() const;
  inline void set_used(::google::protobuf::uint64 value);

  // optional uint64 assigned = 3;
  inline bool has_assigned() const;
  inline void clear_assigned();
  static const int kAssignedFieldNumber = 3;
  inline ::google::protobuf::uint64 assigned() const;
  inline void set_assigned(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:dos.Memory)
 private:
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_used();
  inline void clear_has_used();
  inline void set_has_assigned();
  inline void clear_has_assigned();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 limit_;
  ::google::protobuf::uint64 used_;
  ::google::protobuf::uint64 assigned_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static Memory* default_instance_;
};
// -------------------------------------------------------------------

class Range : public ::google::protobuf::Message {
 public:
  Range();
  virtual ~Range();

  Range(const Range& from);

  inline Range& operator=(const Range& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Range& default_instance();

  void Swap(Range* other);

  // implements Message ----------------------------------------------

  Range* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Range& from);
  void MergeFrom(const Range& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline ::google::protobuf::uint32 start() const;
  inline void set_start(::google::protobuf::uint32 value);

  // optional uint32 end = 2;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 2;
  inline ::google::protobuf::uint32 end() const;
  inline void set_end(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dos.Range)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 start_;
  ::google::protobuf::uint32 end_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static Range* default_instance_;
};
// -------------------------------------------------------------------

class Port : public ::google::protobuf::Message {
 public:
  Port();
  virtual ~Port();

  Port(const Port& from);

  inline Port& operator=(const Port& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Port& default_instance();

  void Swap(Port* other);

  // implements Message ----------------------------------------------

  Port* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Port& from);
  void MergeFrom(const Port& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .dos.Range range = 1;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 1;
  inline const ::dos::Range& range() const;
  inline ::dos::Range* mutable_range();
  inline ::dos::Range* release_range();
  inline void set_allocated_range(::dos::Range* range);

  // repeated uint32 assigned = 2;
  inline int assigned_size() const;
  inline void clear_assigned();
  static const int kAssignedFieldNumber = 2;
  inline ::google::protobuf::uint32 assigned(int index) const;
  inline void set_assigned(int index, ::google::protobuf::uint32 value);
  inline void add_assigned(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      assigned() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_assigned();

  // @@protoc_insertion_point(class_scope:dos.Port)
 private:
  inline void set_has_range();
  inline void clear_has_range();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::dos::Range* range_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > assigned_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static Port* default_instance_;
};
// -------------------------------------------------------------------

class Network : public ::google::protobuf::Message {
 public:
  Network();
  virtual ~Network();

  Network(const Network& from);

  inline Network& operator=(const Network& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Network& default_instance();

  void Swap(Network* other);

  // implements Message ----------------------------------------------

  Network* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Network& from);
  void MergeFrom(const Network& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 out_bytes_ps_limit = 1;
  inline bool has_out_bytes_ps_limit() const;
  inline void clear_out_bytes_ps_limit();
  static const int kOutBytesPsLimitFieldNumber = 1;
  inline ::google::protobuf::uint32 out_bytes_ps_limit() const;
  inline void set_out_bytes_ps_limit(::google::protobuf::uint32 value);

  // optional uint32 out_bytes_ps_used = 2;
  inline bool has_out_bytes_ps_used() const;
  inline void clear_out_bytes_ps_used();
  static const int kOutBytesPsUsedFieldNumber = 2;
  inline ::google::protobuf::uint32 out_bytes_ps_used() const;
  inline void set_out_bytes_ps_used(::google::protobuf::uint32 value);

  // optional uint32 out_bytes_ps_assigned = 3;
  inline bool has_out_bytes_ps_assigned() const;
  inline void clear_out_bytes_ps_assigned();
  static const int kOutBytesPsAssignedFieldNumber = 3;
  inline ::google::protobuf::uint32 out_bytes_ps_assigned() const;
  inline void set_out_bytes_ps_assigned(::google::protobuf::uint32 value);

  // optional uint32 in_bytes_ps_limit = 4;
  inline bool has_in_bytes_ps_limit() const;
  inline void clear_in_bytes_ps_limit();
  static const int kInBytesPsLimitFieldNumber = 4;
  inline ::google::protobuf::uint32 in_bytes_ps_limit() const;
  inline void set_in_bytes_ps_limit(::google::protobuf::uint32 value);

  // optional uint32 in_bytes_ps_used = 5;
  inline bool has_in_bytes_ps_used() const;
  inline void clear_in_bytes_ps_used();
  static const int kInBytesPsUsedFieldNumber = 5;
  inline ::google::protobuf::uint32 in_bytes_ps_used() const;
  inline void set_in_bytes_ps_used(::google::protobuf::uint32 value);

  // optional uint32 in_bytes_ps_assigned = 6;
  inline bool has_in_bytes_ps_assigned() const;
  inline void clear_in_bytes_ps_assigned();
  static const int kInBytesPsAssignedFieldNumber = 6;
  inline ::google::protobuf::uint32 in_bytes_ps_assigned() const;
  inline void set_in_bytes_ps_assigned(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dos.Network)
 private:
  inline void set_has_out_bytes_ps_limit();
  inline void clear_has_out_bytes_ps_limit();
  inline void set_has_out_bytes_ps_used();
  inline void clear_has_out_bytes_ps_used();
  inline void set_has_out_bytes_ps_assigned();
  inline void clear_has_out_bytes_ps_assigned();
  inline void set_has_in_bytes_ps_limit();
  inline void clear_has_in_bytes_ps_limit();
  inline void set_has_in_bytes_ps_used();
  inline void clear_has_in_bytes_ps_used();
  inline void set_has_in_bytes_ps_assigned();
  inline void clear_has_in_bytes_ps_assigned();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 out_bytes_ps_limit_;
  ::google::protobuf::uint32 out_bytes_ps_used_;
  ::google::protobuf::uint32 out_bytes_ps_assigned_;
  ::google::protobuf::uint32 in_bytes_ps_limit_;
  ::google::protobuf::uint32 in_bytes_ps_used_;
  ::google::protobuf::uint32 in_bytes_ps_assigned_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static Network* default_instance_;
};
// -------------------------------------------------------------------

class DiskIO : public ::google::protobuf::Message {
 public:
  DiskIO();
  virtual ~DiskIO();

  DiskIO(const DiskIO& from);

  inline DiskIO& operator=(const DiskIO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiskIO& default_instance();

  void Swap(DiskIO* other);

  // implements Message ----------------------------------------------

  DiskIO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DiskIO& from);
  void MergeFrom(const DiskIO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 read_bytes_ps_limit = 1;
  inline bool has_read_bytes_ps_limit() const;
  inline void clear_read_bytes_ps_limit();
  static const int kReadBytesPsLimitFieldNumber = 1;
  inline ::google::protobuf::uint32 read_bytes_ps_limit() const;
  inline void set_read_bytes_ps_limit(::google::protobuf::uint32 value);

  // optional uint32 read_bytes_ps_used = 2;
  inline bool has_read_bytes_ps_used() const;
  inline void clear_read_bytes_ps_used();
  static const int kReadBytesPsUsedFieldNumber = 2;
  inline ::google::protobuf::uint32 read_bytes_ps_used() const;
  inline void set_read_bytes_ps_used(::google::protobuf::uint32 value);

  // optional uint32 read_bytes_ps_assigned = 3;
  inline bool has_read_bytes_ps_assigned() const;
  inline void clear_read_bytes_ps_assigned();
  static const int kReadBytesPsAssignedFieldNumber = 3;
  inline ::google::protobuf::uint32 read_bytes_ps_assigned() const;
  inline void set_read_bytes_ps_assigned(::google::protobuf::uint32 value);

  // optional uint32 write_bytes_ps_limit = 4;
  inline bool has_write_bytes_ps_limit() const;
  inline void clear_write_bytes_ps_limit();
  static const int kWriteBytesPsLimitFieldNumber = 4;
  inline ::google::protobuf::uint32 write_bytes_ps_limit() const;
  inline void set_write_bytes_ps_limit(::google::protobuf::uint32 value);

  // optional uint32 write_bytes_ps_used = 5;
  inline bool has_write_bytes_ps_used() const;
  inline void clear_write_bytes_ps_used();
  static const int kWriteBytesPsUsedFieldNumber = 5;
  inline ::google::protobuf::uint32 write_bytes_ps_used() const;
  inline void set_write_bytes_ps_used(::google::protobuf::uint32 value);

  // optional uint32 write_bytes_ps_assigned = 6;
  inline bool has_write_bytes_ps_assigned() const;
  inline void clear_write_bytes_ps_assigned();
  static const int kWriteBytesPsAssignedFieldNumber = 6;
  inline ::google::protobuf::uint32 write_bytes_ps_assigned() const;
  inline void set_write_bytes_ps_assigned(::google::protobuf::uint32 value);

  // optional string device = 7;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 7;
  inline const ::std::string& device() const;
  inline void set_device(const ::std::string& value);
  inline void set_device(const char* value);
  inline void set_device(const char* value, size_t size);
  inline ::std::string* mutable_device();
  inline ::std::string* release_device();
  inline void set_allocated_device(::std::string* device);

  // @@protoc_insertion_point(class_scope:dos.DiskIO)
 private:
  inline void set_has_read_bytes_ps_limit();
  inline void clear_has_read_bytes_ps_limit();
  inline void set_has_read_bytes_ps_used();
  inline void clear_has_read_bytes_ps_used();
  inline void set_has_read_bytes_ps_assigned();
  inline void clear_has_read_bytes_ps_assigned();
  inline void set_has_write_bytes_ps_limit();
  inline void clear_has_write_bytes_ps_limit();
  inline void set_has_write_bytes_ps_used();
  inline void clear_has_write_bytes_ps_used();
  inline void set_has_write_bytes_ps_assigned();
  inline void clear_has_write_bytes_ps_assigned();
  inline void set_has_device();
  inline void clear_has_device();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 read_bytes_ps_limit_;
  ::google::protobuf::uint32 read_bytes_ps_used_;
  ::google::protobuf::uint32 read_bytes_ps_assigned_;
  ::google::protobuf::uint32 write_bytes_ps_limit_;
  ::google::protobuf::uint32 write_bytes_ps_used_;
  ::google::protobuf::uint32 write_bytes_ps_assigned_;
  ::std::string* device_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static DiskIO* default_instance_;
};
// -------------------------------------------------------------------

class Resource : public ::google::protobuf::Message {
 public:
  Resource();
  virtual ~Resource();

  Resource(const Resource& from);

  inline Resource& operator=(const Resource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource& default_instance();

  void Swap(Resource* other);

  // implements Message ----------------------------------------------

  Resource* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource& from);
  void MergeFrom(const Resource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .dos.Cpu cpu = 1;
  inline bool has_cpu() const;
  inline void clear_cpu();
  static const int kCpuFieldNumber = 1;
  inline const ::dos::Cpu& cpu() const;
  inline ::dos::Cpu* mutable_cpu();
  inline ::dos::Cpu* release_cpu();
  inline void set_allocated_cpu(::dos::Cpu* cpu);

  // optional .dos.Memory memory = 2;
  inline bool has_memory() const;
  inline void clear_memory();
  static const int kMemoryFieldNumber = 2;
  inline const ::dos::Memory& memory() const;
  inline ::dos::Memory* mutable_memory();
  inline ::dos::Memory* release_memory();
  inline void set_allocated_memory(::dos::Memory* memory);

  // optional .dos.Port port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline const ::dos::Port& port() const;
  inline ::dos::Port* mutable_port();
  inline ::dos::Port* release_port();
  inline void set_allocated_port(::dos::Port* port);

  // optional .dos.Network network = 4;
  inline bool has_network() const;
  inline void clear_network();
  static const int kNetworkFieldNumber = 4;
  inline const ::dos::Network& network() const;
  inline ::dos::Network* mutable_network();
  inline ::dos::Network* release_network();
  inline void set_allocated_network(::dos::Network* network);

  // repeated .dos.DiskIO diskio = 5;
  inline int diskio_size() const;
  inline void clear_diskio();
  static const int kDiskioFieldNumber = 5;
  inline const ::dos::DiskIO& diskio(int index) const;
  inline ::dos::DiskIO* mutable_diskio(int index);
  inline ::dos::DiskIO* add_diskio();
  inline const ::google::protobuf::RepeatedPtrField< ::dos::DiskIO >&
      diskio() const;
  inline ::google::protobuf::RepeatedPtrField< ::dos::DiskIO >*
      mutable_diskio();

  // optional uint64 gtime = 6;
  inline bool has_gtime() const;
  inline void clear_gtime();
  static const int kGtimeFieldNumber = 6;
  inline ::google::protobuf::uint64 gtime() const;
  inline void set_gtime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:dos.Resource)
 private:
  inline void set_has_cpu();
  inline void clear_has_cpu();
  inline void set_has_memory();
  inline void clear_has_memory();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_network();
  inline void clear_has_network();
  inline void set_has_gtime();
  inline void clear_has_gtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::dos::Cpu* cpu_;
  ::dos::Memory* memory_;
  ::dos::Port* port_;
  ::dos::Network* network_;
  ::google::protobuf::RepeatedPtrField< ::dos::DiskIO > diskio_;
  ::google::protobuf::uint64 gtime_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static Resource* default_instance_;
};
// -------------------------------------------------------------------

class Process : public ::google::protobuf::Message {
 public:
  Process();
  virtual ~Process();

  Process(const Process& from);

  inline Process& operator=(const Process& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Process& default_instance();

  void Swap(Process* other);

  // implements Message ----------------------------------------------

  Process* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Process& from);
  void MergeFrom(const Process& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string args = 1;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 1;
  inline const ::std::string& args(int index) const;
  inline ::std::string* mutable_args(int index);
  inline void set_args(int index, const ::std::string& value);
  inline void set_args(int index, const char* value);
  inline void set_args(int index, const char* value, size_t size);
  inline ::std::string* add_args();
  inline void add_args(const ::std::string& value);
  inline void add_args(const char* value);
  inline void add_args(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& args() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_args();

  // optional .dos.User user = 2;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 2;
  inline const ::dos::User& user() const;
  inline ::dos::User* mutable_user();
  inline ::dos::User* release_user();
  inline void set_allocated_user(::dos::User* user);

  // repeated string envs = 3;
  inline int envs_size() const;
  inline void clear_envs();
  static const int kEnvsFieldNumber = 3;
  inline const ::std::string& envs(int index) const;
  inline ::std::string* mutable_envs(int index);
  inline void set_envs(int index, const ::std::string& value);
  inline void set_envs(int index, const char* value);
  inline void set_envs(int index, const char* value, size_t size);
  inline ::std::string* add_envs();
  inline void add_envs(const ::std::string& value);
  inline void add_envs(const char* value);
  inline void add_envs(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& envs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_envs();

  // optional string cwd = 4;
  inline bool has_cwd() const;
  inline void clear_cwd();
  static const int kCwdFieldNumber = 4;
  inline const ::std::string& cwd() const;
  inline void set_cwd(const ::std::string& value);
  inline void set_cwd(const char* value);
  inline void set_cwd(const char* value, size_t size);
  inline ::std::string* mutable_cwd();
  inline ::std::string* release_cwd();
  inline void set_allocated_cwd(::std::string* cwd);

  // optional string pty = 5;
  inline bool has_pty() const;
  inline void clear_pty();
  static const int kPtyFieldNumber = 5;
  inline const ::std::string& pty() const;
  inline void set_pty(const ::std::string& value);
  inline void set_pty(const char* value);
  inline void set_pty(const char* value, size_t size);
  inline ::std::string* mutable_pty();
  inline ::std::string* release_pty();
  inline void set_allocated_pty(::std::string* pty);

  // optional bool running = 6;
  inline bool has_running() const;
  inline void clear_running();
  static const int kRunningFieldNumber = 6;
  inline bool running() const;
  inline void set_running(bool value);

  // optional int32 pid = 7;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 7;
  inline ::google::protobuf::int32 pid() const;
  inline void set_pid(::google::protobuf::int32 value);

  // optional int32 gpid = 8;
  inline bool has_gpid() const;
  inline void clear_gpid();
  static const int kGpidFieldNumber = 8;
  inline ::google::protobuf::int32 gpid() const;
  inline void set_gpid(::google::protobuf::int32 value);

  // optional int64 rtime = 9;
  inline bool has_rtime() const;
  inline void clear_rtime();
  static const int kRtimeFieldNumber = 9;
  inline ::google::protobuf::int64 rtime() const;
  inline void set_rtime(::google::protobuf::int64 value);

  // optional bool coredump = 10;
  inline bool has_coredump() const;
  inline void clear_coredump();
  static const int kCoredumpFieldNumber = 10;
  inline bool coredump() const;
  inline void set_coredump(bool value);

  // optional int32 exit_code = 11;
  inline bool has_exit_code() const;
  inline void clear_exit_code();
  static const int kExitCodeFieldNumber = 11;
  inline ::google::protobuf::int32 exit_code() const;
  inline void set_exit_code(::google::protobuf::int32 value);

  // optional string name = 12;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 12;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool terminal = 13;
  inline bool has_terminal() const;
  inline void clear_terminal();
  static const int kTerminalFieldNumber = 13;
  inline bool terminal() const;
  inline void set_terminal(bool value);

  // optional string interceptor = 14;
  inline bool has_interceptor() const;
  inline void clear_interceptor();
  static const int kInterceptorFieldNumber = 14;
  inline const ::std::string& interceptor() const;
  inline void set_interceptor(const ::std::string& value);
  inline void set_interceptor(const char* value);
  inline void set_interceptor(const char* value, size_t size);
  inline ::std::string* mutable_interceptor();
  inline ::std::string* release_interceptor();
  inline void set_allocated_interceptor(::std::string* interceptor);

  // optional string hostname = 15;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 15;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // @@protoc_insertion_point(class_scope:dos.Process)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_cwd();
  inline void clear_has_cwd();
  inline void set_has_pty();
  inline void clear_has_pty();
  inline void set_has_running();
  inline void clear_has_running();
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_gpid();
  inline void clear_has_gpid();
  inline void set_has_rtime();
  inline void clear_has_rtime();
  inline void set_has_coredump();
  inline void clear_has_coredump();
  inline void set_has_exit_code();
  inline void clear_has_exit_code();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_terminal();
  inline void clear_has_terminal();
  inline void set_has_interceptor();
  inline void clear_has_interceptor();
  inline void set_has_hostname();
  inline void clear_has_hostname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> args_;
  ::dos::User* user_;
  ::google::protobuf::RepeatedPtrField< ::std::string> envs_;
  ::std::string* cwd_;
  ::std::string* pty_;
  ::google::protobuf::int32 pid_;
  ::google::protobuf::int32 gpid_;
  ::google::protobuf::int64 rtime_;
  bool running_;
  bool coredump_;
  bool terminal_;
  ::google::protobuf::int32 exit_code_;
  ::std::string* name_;
  ::std::string* interceptor_;
  ::std::string* hostname_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static Process* default_instance_;
};
// -------------------------------------------------------------------

class Platform : public ::google::protobuf::Message {
 public:
  Platform();
  virtual ~Platform();

  Platform(const Platform& from);

  inline Platform& operator=(const Platform& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Platform& default_instance();

  void Swap(Platform* other);

  // implements Message ----------------------------------------------

  Platform* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Platform& from);
  void MergeFrom(const Platform& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string os = 1;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 1;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  inline ::std::string* release_os();
  inline void set_allocated_os(::std::string* os);

  // optional string arch = 2;
  inline bool has_arch() const;
  inline void clear_arch();
  static const int kArchFieldNumber = 2;
  inline const ::std::string& arch() const;
  inline void set_arch(const ::std::string& value);
  inline void set_arch(const char* value);
  inline void set_arch(const char* value, size_t size);
  inline ::std::string* mutable_arch();
  inline ::std::string* release_arch();
  inline void set_allocated_arch(::std::string* arch);

  // @@protoc_insertion_point(class_scope:dos.Platform)
 private:
  inline void set_has_os();
  inline void clear_has_os();
  inline void set_has_arch();
  inline void clear_has_arch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* os_;
  ::std::string* arch_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static Platform* default_instance_;
};
// -------------------------------------------------------------------

class Root : public ::google::protobuf::Message {
 public:
  Root();
  virtual ~Root();

  Root(const Root& from);

  inline Root& operator=(const Root& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Root& default_instance();

  void Swap(Root* other);

  // implements Message ----------------------------------------------

  Root* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Root& from);
  void MergeFrom(const Root& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional bool readonly = 2;
  inline bool has_readonly() const;
  inline void clear_readonly();
  static const int kReadonlyFieldNumber = 2;
  inline bool readonly() const;
  inline void set_readonly(bool value);

  // @@protoc_insertion_point(class_scope:dos.Root)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_readonly();
  inline void clear_has_readonly();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  bool readonly_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static Root* default_instance_;
};
// -------------------------------------------------------------------

class Mount : public ::google::protobuf::Message {
 public:
  Mount();
  virtual ~Mount();

  Mount(const Mount& from);

  inline Mount& operator=(const Mount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mount& default_instance();

  void Swap(Mount* other);

  // implements Message ----------------------------------------------

  Mount* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mount& from);
  void MergeFrom(const Mount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string source = 5;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 5;
  inline const ::std::string& source() const;
  inline void set_source(const ::std::string& value);
  inline void set_source(const char* value);
  inline void set_source(const char* value, size_t size);
  inline ::std::string* mutable_source();
  inline ::std::string* release_source();
  inline void set_allocated_source(::std::string* source);

  // optional string destination = 6;
  inline bool has_destination() const;
  inline void clear_destination();
  static const int kDestinationFieldNumber = 6;
  inline const ::std::string& destination() const;
  inline void set_destination(const ::std::string& value);
  inline void set_destination(const char* value);
  inline void set_destination(const char* value, size_t size);
  inline ::std::string* mutable_destination();
  inline ::std::string* release_destination();
  inline void set_allocated_destination(::std::string* destination);

  // repeated string options = 7;
  inline int options_size() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 7;
  inline const ::std::string& options(int index) const;
  inline ::std::string* mutable_options(int index);
  inline void set_options(int index, const ::std::string& value);
  inline void set_options(int index, const char* value);
  inline void set_options(int index, const char* value, size_t size);
  inline ::std::string* add_options();
  inline void add_options(const ::std::string& value);
  inline void add_options(const char* value);
  inline void add_options(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& options() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_options();

  // @@protoc_insertion_point(class_scope:dos.Mount)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_destination();
  inline void clear_has_destination();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* path_;
  ::std::string* type_;
  ::std::string* source_;
  ::std::string* destination_;
  ::google::protobuf::RepeatedPtrField< ::std::string> options_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static Mount* default_instance_;
};
// -------------------------------------------------------------------

class Device : public ::google::protobuf::Message {
 public:
  Device();
  virtual ~Device();

  Device(const Device& from);

  inline Device& operator=(const Device& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Device& default_instance();

  void Swap(Device* other);

  // implements Message ----------------------------------------------

  Device* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Device& from);
  void MergeFrom(const Device& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 major = 3;
  inline bool has_major() const;
  inline void clear_major();
  static const int kMajorFieldNumber = 3;
  inline ::google::protobuf::int32 major() const;
  inline void set_major(::google::protobuf::int32 value);

  // optional int32 minor = 4;
  inline bool has_minor() const;
  inline void clear_minor();
  static const int kMinorFieldNumber = 4;
  inline ::google::protobuf::int32 minor() const;
  inline void set_minor(::google::protobuf::int32 value);

  // optional string permissions = 5;
  inline bool has_permissions() const;
  inline void clear_permissions();
  static const int kPermissionsFieldNumber = 5;
  inline const ::std::string& permissions() const;
  inline void set_permissions(const ::std::string& value);
  inline void set_permissions(const char* value);
  inline void set_permissions(const char* value, size_t size);
  inline ::std::string* mutable_permissions();
  inline ::std::string* release_permissions();
  inline void set_allocated_permissions(::std::string* permissions);

  // optional int32 mode = 6;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 6;
  inline ::google::protobuf::int32 mode() const;
  inline void set_mode(::google::protobuf::int32 value);

  // optional int32 uid = 7;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 7;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional int32 gid = 8;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 8;
  inline ::google::protobuf::int32 gid() const;
  inline void set_gid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dos.Device)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_major();
  inline void clear_has_major();
  inline void set_has_minor();
  inline void clear_has_minor();
  inline void set_has_permissions();
  inline void clear_has_permissions();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_gid();
  inline void clear_has_gid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 major_;
  ::std::string* permissions_;
  ::google::protobuf::int32 minor_;
  ::google::protobuf::int32 mode_;
  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 gid_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static Device* default_instance_;
};
// -------------------------------------------------------------------

class NodeMeta : public ::google::protobuf::Message {
 public:
  NodeMeta();
  virtual ~NodeMeta();

  NodeMeta(const NodeMeta& from);

  inline NodeMeta& operator=(const NodeMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeMeta& default_instance();

  void Swap(NodeMeta* other);

  // implements Message ----------------------------------------------

  NodeMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeMeta& from);
  void MergeFrom(const NodeMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional string hostname = 2;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 2;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional string endpoint = 3;
  inline bool has_endpoint() const;
  inline void clear_endpoint();
  static const int kEndpointFieldNumber = 3;
  inline const ::std::string& endpoint() const;
  inline void set_endpoint(const ::std::string& value);
  inline void set_endpoint(const char* value);
  inline void set_endpoint(const char* value, size_t size);
  inline ::std::string* mutable_endpoint();
  inline ::std::string* release_endpoint();
  inline void set_allocated_endpoint(::std::string* endpoint);

  // optional .dos.Resource resource = 4;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 4;
  inline const ::dos::Resource& resource() const;
  inline ::dos::Resource* mutable_resource();
  inline ::dos::Resource* release_resource();
  inline void set_allocated_resource(::dos::Resource* resource);

  // @@protoc_insertion_point(class_scope:dos.NodeMeta)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_endpoint();
  inline void clear_has_endpoint();
  inline void set_has_resource();
  inline void clear_has_resource();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_;
  ::std::string* hostname_;
  ::std::string* endpoint_;
  ::dos::Resource* resource_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static NodeMeta* default_instance_;
};
// -------------------------------------------------------------------

class Container : public ::google::protobuf::Message {
 public:
  Container();
  virtual ~Container();

  Container(const Container& from);

  inline Container& operator=(const Container& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Container& default_instance();

  void Swap(Container* other);

  // implements Message ----------------------------------------------

  Container* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Container& from);
  void MergeFrom(const Container& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .dos.Resource requirement = 1;
  inline bool has_requirement() const;
  inline void clear_requirement();
  static const int kRequirementFieldNumber = 1;
  inline const ::dos::Resource& requirement() const;
  inline ::dos::Resource* mutable_requirement();
  inline ::dos::Resource* release_requirement();
  inline void set_allocated_requirement(::dos::Resource* requirement);

  // optional string image = 2;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 2;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const char* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  inline void set_allocated_image(::std::string* image);

  // optional string tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // optional string uri = 4;
  inline bool has_uri() const;
  inline void clear_uri();
  static const int kUriFieldNumber = 4;
  inline const ::std::string& uri() const;
  inline void set_uri(const ::std::string& value);
  inline void set_uri(const char* value);
  inline void set_uri(const char* value, size_t size);
  inline ::std::string* mutable_uri();
  inline ::std::string* release_uri();
  inline void set_allocated_uri(::std::string* uri);

  // optional .dos.ContainerType type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::dos::ContainerType type() const;
  inline void set_type(::dos::ContainerType value);

  // optional bool enable_ns = 6;
  inline bool has_enable_ns() const;
  inline void clear_enable_ns();
  static const int kEnableNsFieldNumber = 6;
  inline bool enable_ns() const;
  inline void set_enable_ns(bool value);

  // optional int32 reserve_time = 7;
  inline bool has_reserve_time() const;
  inline void clear_reserve_time();
  static const int kReserveTimeFieldNumber = 7;
  inline ::google::protobuf::int32 reserve_time() const;
  inline void set_reserve_time(::google::protobuf::int32 value);

  // optional .dos.RestartStrategy restart_strategy = 8;
  inline bool has_restart_strategy() const;
  inline void clear_restart_strategy();
  static const int kRestartStrategyFieldNumber = 8;
  inline ::dos::RestartStrategy restart_strategy() const;
  inline void set_restart_strategy(::dos::RestartStrategy value);

  // @@protoc_insertion_point(class_scope:dos.Container)
 private:
  inline void set_has_requirement();
  inline void clear_has_requirement();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_uri();
  inline void clear_has_uri();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_enable_ns();
  inline void clear_has_enable_ns();
  inline void set_has_reserve_time();
  inline void clear_has_reserve_time();
  inline void set_has_restart_strategy();
  inline void clear_has_restart_strategy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::dos::Resource* requirement_;
  ::std::string* image_;
  ::std::string* tag_;
  ::std::string* uri_;
  int type_;
  bool enable_ns_;
  ::google::protobuf::int32 reserve_time_;
  int restart_strategy_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static Container* default_instance_;
};
// -------------------------------------------------------------------

class PodSpec : public ::google::protobuf::Message {
 public:
  PodSpec();
  virtual ~PodSpec();

  PodSpec(const PodSpec& from);

  inline PodSpec& operator=(const PodSpec& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PodSpec& default_instance();

  void Swap(PodSpec* other);

  // implements Message ----------------------------------------------

  PodSpec* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PodSpec& from);
  void MergeFrom(const PodSpec& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .dos.Container containers = 1;
  inline int containers_size() const;
  inline void clear_containers();
  static const int kContainersFieldNumber = 1;
  inline const ::dos::Container& containers(int index) const;
  inline ::dos::Container* mutable_containers(int index);
  inline ::dos::Container* add_containers();
  inline const ::google::protobuf::RepeatedPtrField< ::dos::Container >&
      containers() const;
  inline ::google::protobuf::RepeatedPtrField< ::dos::Container >*
      mutable_containers();

  // optional int32 log_size = 2;
  inline bool has_log_size() const;
  inline void clear_log_size();
  static const int kLogSizeFieldNumber = 2;
  inline ::google::protobuf::int32 log_size() const;
  inline void set_log_size(::google::protobuf::int32 value);

  // optional .dos.PodType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::dos::PodType type() const;
  inline void set_type(::dos::PodType value);

  // @@protoc_insertion_point(class_scope:dos.PodSpec)
 private:
  inline void set_has_log_size();
  inline void clear_has_log_size();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::dos::Container > containers_;
  ::google::protobuf::int32 log_size_;
  int type_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static PodSpec* default_instance_;
};
// -------------------------------------------------------------------

class JobSpec : public ::google::protobuf::Message {
 public:
  JobSpec();
  virtual ~JobSpec();

  JobSpec(const JobSpec& from);

  inline JobSpec& operator=(const JobSpec& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JobSpec& default_instance();

  void Swap(JobSpec* other);

  // implements Message ----------------------------------------------

  JobSpec* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobSpec& from);
  void MergeFrom(const JobSpec& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 replica = 2;
  inline bool has_replica() const;
  inline void clear_replica();
  static const int kReplicaFieldNumber = 2;
  inline ::google::protobuf::uint32 replica() const;
  inline void set_replica(::google::protobuf::uint32 value);

  // optional uint32 deploy_step_size = 3;
  inline bool has_deploy_step_size() const;
  inline void clear_deploy_step_size();
  static const int kDeployStepSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 deploy_step_size() const;
  inline void set_deploy_step_size(::google::protobuf::uint32 value);

  // optional uint32 update_step_size = 4;
  inline bool has_update_step_size() const;
  inline void clear_update_step_size();
  static const int kUpdateStepSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 update_step_size() const;
  inline void set_update_step_size(::google::protobuf::uint32 value);

  // optional .dos.PodSpec pod = 5;
  inline bool has_pod() const;
  inline void clear_pod();
  static const int kPodFieldNumber = 5;
  inline const ::dos::PodSpec& pod() const;
  inline ::dos::PodSpec* mutable_pod();
  inline ::dos::PodSpec* release_pod();
  inline void set_allocated_pod(::dos::PodSpec* pod);

  // optional string version = 6;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 6;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional bytes raw = 7;
  inline bool has_raw() const;
  inline void clear_raw();
  static const int kRawFieldNumber = 7;
  inline const ::std::string& raw() const;
  inline void set_raw(const ::std::string& value);
  inline void set_raw(const char* value);
  inline void set_raw(const void* value, size_t size);
  inline ::std::string* mutable_raw();
  inline ::std::string* release_raw();
  inline void set_allocated_raw(::std::string* raw);

  // @@protoc_insertion_point(class_scope:dos.JobSpec)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_replica();
  inline void clear_has_replica();
  inline void set_has_deploy_step_size();
  inline void clear_has_deploy_step_size();
  inline void set_has_update_step_size();
  inline void clear_has_update_step_size();
  inline void set_has_pod();
  inline void clear_has_pod();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_raw();
  inline void clear_has_raw();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint32 replica_;
  ::google::protobuf::uint32 deploy_step_size_;
  ::dos::PodSpec* pod_;
  ::std::string* version_;
  ::std::string* raw_;
  ::google::protobuf::uint32 update_step_size_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static JobSpec* default_instance_;
};
// -------------------------------------------------------------------

class JobStatus : public ::google::protobuf::Message {
 public:
  JobStatus();
  virtual ~JobStatus();

  JobStatus(const JobStatus& from);

  inline JobStatus& operator=(const JobStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JobStatus& default_instance();

  void Swap(JobStatus* other);

  // implements Message ----------------------------------------------

  JobStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobStatus& from);
  void MergeFrom(const JobStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .dos.JobState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::dos::JobState state() const;
  inline void set_state(::dos::JobState value);

  // optional string user_name = 3;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 3;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional int64 ctime = 4;
  inline bool has_ctime() const;
  inline void clear_ctime();
  static const int kCtimeFieldNumber = 4;
  inline ::google::protobuf::int64 ctime() const;
  inline void set_ctime(::google::protobuf::int64 value);

  // optional int64 utime = 5;
  inline bool has_utime() const;
  inline void clear_utime();
  static const int kUtimeFieldNumber = 5;
  inline ::google::protobuf::int64 utime() const;
  inline void set_utime(::google::protobuf::int64 value);

  // optional .dos.JobSpec desc = 6;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 6;
  inline const ::dos::JobSpec& desc() const;
  inline ::dos::JobSpec* mutable_desc();
  inline ::dos::JobSpec* release_desc();
  inline void set_allocated_desc(::dos::JobSpec* desc);

  // @@protoc_insertion_point(class_scope:dos.JobStatus)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_ctime();
  inline void clear_has_ctime();
  inline void set_has_utime();
  inline void clear_has_utime();
  inline void set_has_desc();
  inline void clear_has_desc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* user_name_;
  ::google::protobuf::int64 ctime_;
  ::google::protobuf::int64 utime_;
  ::dos::JobSpec* desc_;
  int state_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static JobStatus* default_instance_;
};
// -------------------------------------------------------------------

class PodLog : public ::google::protobuf::Message {
 public:
  PodLog();
  virtual ~PodLog();

  PodLog(const PodLog& from);

  inline PodLog& operator=(const PodLog& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PodLog& default_instance();

  void Swap(PodLog* other);

  // implements Message ----------------------------------------------

  PodLog* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PodLog& from);
  void MergeFrom(const PodLog& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .dos.PodState state_from = 2;
  inline bool has_state_from() const;
  inline void clear_state_from();
  static const int kStateFromFieldNumber = 2;
  inline ::dos::PodState state_from() const;
  inline void set_state_from(::dos::PodState value);

  // optional .dos.PodState state_to = 3;
  inline bool has_state_to() const;
  inline void clear_state_to();
  static const int kStateToFieldNumber = 3;
  inline ::dos::PodState state_to() const;
  inline void set_state_to(::dos::PodState value);

  // optional int64 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // optional string msg = 5;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 5;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:dos.PodLog)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_state_from();
  inline void clear_has_state_from();
  inline void set_has_state_to();
  inline void clear_has_state_to();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  int state_from_;
  int state_to_;
  ::google::protobuf::int64 time_;
  ::std::string* msg_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static PodLog* default_instance_;
};
// -------------------------------------------------------------------

class PodStatus : public ::google::protobuf::Message {
 public:
  PodStatus();
  virtual ~PodStatus();

  PodStatus(const PodStatus& from);

  inline PodStatus& operator=(const PodStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PodStatus& default_instance();

  void Swap(PodStatus* other);

  // implements Message ----------------------------------------------

  PodStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PodStatus& from);
  void MergeFrom(const PodStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .dos.ContainerStatus cstatus = 2;
  inline int cstatus_size() const;
  inline void clear_cstatus();
  static const int kCstatusFieldNumber = 2;
  inline const ::dos::ContainerStatus& cstatus(int index) const;
  inline ::dos::ContainerStatus* mutable_cstatus(int index);
  inline ::dos::ContainerStatus* add_cstatus();
  inline const ::google::protobuf::RepeatedPtrField< ::dos::ContainerStatus >&
      cstatus() const;
  inline ::google::protobuf::RepeatedPtrField< ::dos::ContainerStatus >*
      mutable_cstatus();

  // optional .dos.PodSpec desc = 3;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 3;
  inline const ::dos::PodSpec& desc() const;
  inline ::dos::PodSpec* mutable_desc();
  inline ::dos::PodSpec* release_desc();
  inline void set_allocated_desc(::dos::PodSpec* desc);

  // optional .dos.PodSchedStage stage = 4;
  inline bool has_stage() const;
  inline void clear_stage();
  static const int kStageFieldNumber = 4;
  inline ::dos::PodSchedStage stage() const;
  inline void set_stage(::dos::PodSchedStage value);

  // optional .dos.PodState state = 5;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 5;
  inline ::dos::PodState state() const;
  inline void set_state(::dos::PodState value);

  // optional int64 sched_time = 6;
  inline bool has_sched_time() const;
  inline void clear_sched_time();
  static const int kSchedTimeFieldNumber = 6;
  inline ::google::protobuf::int64 sched_time() const;
  inline void set_sched_time(::google::protobuf::int64 value);

  // optional int64 boot_time = 7;
  inline bool has_boot_time() const;
  inline void clear_boot_time();
  static const int kBootTimeFieldNumber = 7;
  inline ::google::protobuf::int64 boot_time() const;
  inline void set_boot_time(::google::protobuf::int64 value);

  // optional int64 start_pending_time = 8;
  inline bool has_start_pending_time() const;
  inline void clear_start_pending_time();
  static const int kStartPendingTimeFieldNumber = 8;
  inline ::google::protobuf::int64 start_pending_time() const;
  inline void set_start_pending_time(::google::protobuf::int64 value);

  // optional string endpoint = 9;
  inline bool has_endpoint() const;
  inline void clear_endpoint();
  static const int kEndpointFieldNumber = 9;
  inline const ::std::string& endpoint() const;
  inline void set_endpoint(const ::std::string& value);
  inline void set_endpoint(const char* value);
  inline void set_endpoint(const char* value, size_t size);
  inline ::std::string* mutable_endpoint();
  inline ::std::string* release_endpoint();
  inline void set_allocated_endpoint(::std::string* endpoint);

  // optional string job_name = 10;
  inline bool has_job_name() const;
  inline void clear_job_name();
  static const int kJobNameFieldNumber = 10;
  inline const ::std::string& job_name() const;
  inline void set_job_name(const ::std::string& value);
  inline void set_job_name(const char* value);
  inline void set_job_name(const char* value, size_t size);
  inline ::std::string* mutable_job_name();
  inline ::std::string* release_job_name();
  inline void set_allocated_job_name(::std::string* job_name);

  // @@protoc_insertion_point(class_scope:dos.PodStatus)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_stage();
  inline void clear_has_stage();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_sched_time();
  inline void clear_has_sched_time();
  inline void set_has_boot_time();
  inline void clear_has_boot_time();
  inline void set_has_start_pending_time();
  inline void clear_has_start_pending_time();
  inline void set_has_endpoint();
  inline void clear_has_endpoint();
  inline void set_has_job_name();
  inline void clear_has_job_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::dos::ContainerStatus > cstatus_;
  ::dos::PodSpec* desc_;
  int stage_;
  int state_;
  ::google::protobuf::int64 sched_time_;
  ::google::protobuf::int64 boot_time_;
  ::google::protobuf::int64 start_pending_time_;
  ::std::string* endpoint_;
  ::std::string* job_name_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static PodStatus* default_instance_;
};
// -------------------------------------------------------------------

class NodeStatus : public ::google::protobuf::Message {
 public:
  NodeStatus();
  virtual ~NodeStatus();

  NodeStatus(const NodeStatus& from);

  inline NodeStatus& operator=(const NodeStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeStatus& default_instance();

  void Swap(NodeStatus* other);

  // implements Message ----------------------------------------------

  NodeStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeStatus& from);
  void MergeFrom(const NodeStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .dos.Resource resource = 1;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 1;
  inline const ::dos::Resource& resource() const;
  inline ::dos::Resource* mutable_resource();
  inline ::dos::Resource* release_resource();
  inline void set_allocated_resource(::dos::Resource* resource);

  // repeated .dos.PodStatus pstatus = 2;
  inline int pstatus_size() const;
  inline void clear_pstatus();
  static const int kPstatusFieldNumber = 2;
  inline const ::dos::PodStatus& pstatus(int index) const;
  inline ::dos::PodStatus* mutable_pstatus(int index);
  inline ::dos::PodStatus* add_pstatus();
  inline const ::google::protobuf::RepeatedPtrField< ::dos::PodStatus >&
      pstatus() const;
  inline ::google::protobuf::RepeatedPtrField< ::dos::PodStatus >*
      mutable_pstatus();

  // optional .dos.NodeState state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline ::dos::NodeState state() const;
  inline void set_state(::dos::NodeState value);

  // optional .dos.NodeMeta meta = 4;
  inline bool has_meta() const;
  inline void clear_meta();
  static const int kMetaFieldNumber = 4;
  inline const ::dos::NodeMeta& meta() const;
  inline ::dos::NodeMeta* mutable_meta();
  inline ::dos::NodeMeta* release_meta();
  inline void set_allocated_meta(::dos::NodeMeta* meta);

  // optional int64 task_id = 5;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 5;
  inline ::google::protobuf::int64 task_id() const;
  inline void set_task_id(::google::protobuf::int64 value);

  // optional int32 version = 6;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 6;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dos.NodeStatus)
 private:
  inline void set_has_resource();
  inline void clear_has_resource();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_meta();
  inline void clear_has_meta();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::dos::Resource* resource_;
  ::google::protobuf::RepeatedPtrField< ::dos::PodStatus > pstatus_;
  ::dos::NodeMeta* meta_;
  int state_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::int64 task_id_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static NodeStatus* default_instance_;
};
// -------------------------------------------------------------------

class ContainerLog : public ::google::protobuf::Message {
 public:
  ContainerLog();
  virtual ~ContainerLog();

  ContainerLog(const ContainerLog& from);

  inline ContainerLog& operator=(const ContainerLog& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerLog& default_instance();

  void Swap(ContainerLog* other);

  // implements Message ----------------------------------------------

  ContainerLog* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerLog& from);
  void MergeFrom(const ContainerLog& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .dos.ContainerState cfrom = 2;
  inline bool has_cfrom() const;
  inline void clear_cfrom();
  static const int kCfromFieldNumber = 2;
  inline ::dos::ContainerState cfrom() const;
  inline void set_cfrom(::dos::ContainerState value);

  // optional .dos.ContainerState cto = 3;
  inline bool has_cto() const;
  inline void clear_cto();
  static const int kCtoFieldNumber = 3;
  inline ::dos::ContainerState cto() const;
  inline void set_cto(::dos::ContainerState value);

  // optional int64 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // optional string msg = 5;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 5;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:dos.ContainerLog)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_cfrom();
  inline void clear_has_cfrom();
  inline void set_has_cto();
  inline void clear_has_cto();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  int cfrom_;
  int cto_;
  ::google::protobuf::int64 time_;
  ::std::string* msg_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static ContainerLog* default_instance_;
};
// -------------------------------------------------------------------

class ContainerStatus : public ::google::protobuf::Message {
 public:
  ContainerStatus();
  virtual ~ContainerStatus();

  ContainerStatus(const ContainerStatus& from);

  inline ContainerStatus& operator=(const ContainerStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerStatus& default_instance();

  void Swap(ContainerStatus* other);

  // implements Message ----------------------------------------------

  ContainerStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerStatus& from);
  void MergeFrom(const ContainerStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int64 start_time = 2;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 2;
  inline ::google::protobuf::int64 start_time() const;
  inline void set_start_time(::google::protobuf::int64 value);

  // optional .dos.Resource resource = 3;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 3;
  inline const ::dos::Resource& resource() const;
  inline ::dos::Resource* mutable_resource();
  inline ::dos::Resource* release_resource();
  inline void set_allocated_resource(::dos::Resource* resource);

  // optional .dos.ContainerState state = 4;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 4;
  inline ::dos::ContainerState state() const;
  inline void set_state(::dos::ContainerState value);

  // optional int64 boot_time = 6;
  inline bool has_boot_time() const;
  inline void clear_boot_time();
  static const int kBootTimeFieldNumber = 6;
  inline ::google::protobuf::int64 boot_time() const;
  inline void set_boot_time(::google::protobuf::int64 value);

  // optional .dos.Container spec = 7;
  inline bool has_spec() const;
  inline void clear_spec();
  static const int kSpecFieldNumber = 7;
  inline const ::dos::Container& spec() const;
  inline ::dos::Container* mutable_spec();
  inline ::dos::Container* release_spec();
  inline void set_allocated_spec(::dos::Container* spec);

  // optional int64 last_update = 8;
  inline bool has_last_update() const;
  inline void clear_last_update();
  static const int kLastUpdateFieldNumber = 8;
  inline ::google::protobuf::int64 last_update() const;
  inline void set_last_update(::google::protobuf::int64 value);

  // optional int64 restart_count = 9;
  inline bool has_restart_count() const;
  inline void clear_restart_count();
  static const int kRestartCountFieldNumber = 9;
  inline ::google::protobuf::int64 restart_count() const;
  inline void set_restart_count(::google::protobuf::int64 value);

  // optional string node_addr = 10;
  inline bool has_node_addr() const;
  inline void clear_node_addr();
  static const int kNodeAddrFieldNumber = 10;
  inline const ::std::string& node_addr() const;
  inline void set_node_addr(const ::std::string& value);
  inline void set_node_addr(const char* value);
  inline void set_node_addr(const char* value, size_t size);
  inline ::std::string* mutable_node_addr();
  inline ::std::string* release_node_addr();
  inline void set_allocated_node_addr(::std::string* node_addr);

  // optional .dos.HealthState health_state = 11;
  inline bool has_health_state() const;
  inline void clear_health_state();
  static const int kHealthStateFieldNumber = 11;
  inline ::dos::HealthState health_state() const;
  inline void set_health_state(::dos::HealthState value);

  // optional .dos.Resource lowest = 12;
  inline bool has_lowest() const;
  inline void clear_lowest();
  static const int kLowestFieldNumber = 12;
  inline const ::dos::Resource& lowest() const;
  inline ::dos::Resource* mutable_lowest();
  inline ::dos::Resource* release_lowest();
  inline void set_allocated_lowest(::dos::Resource* lowest);

  // optional .dos.Resource highest = 13;
  inline bool has_highest() const;
  inline void clear_highest();
  static const int kHighestFieldNumber = 13;
  inline const ::dos::Resource& highest() const;
  inline ::dos::Resource* mutable_highest();
  inline ::dos::Resource* release_highest();
  inline void set_allocated_highest(::dos::Resource* highest);

  // @@protoc_insertion_point(class_scope:dos.ContainerStatus)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_resource();
  inline void clear_has_resource();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_boot_time();
  inline void clear_has_boot_time();
  inline void set_has_spec();
  inline void clear_has_spec();
  inline void set_has_last_update();
  inline void clear_has_last_update();
  inline void set_has_restart_count();
  inline void clear_has_restart_count();
  inline void set_has_node_addr();
  inline void clear_has_node_addr();
  inline void set_has_health_state();
  inline void clear_has_health_state();
  inline void set_has_lowest();
  inline void clear_has_lowest();
  inline void set_has_highest();
  inline void clear_has_highest();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::int64 start_time_;
  ::dos::Resource* resource_;
  ::google::protobuf::int64 boot_time_;
  ::dos::Container* spec_;
  ::google::protobuf::int64 last_update_;
  int state_;
  int health_state_;
  ::google::protobuf::int64 restart_count_;
  ::std::string* node_addr_;
  ::dos::Resource* lowest_;
  ::dos::Resource* highest_;
  friend void  protobuf_AddDesc_dos_2eproto();
  friend void protobuf_AssignDesc_dos_2eproto();
  friend void protobuf_ShutdownFile_dos_2eproto();

  void InitAsDefaultInstance();
  static ContainerStatus* default_instance_;
};
// ===================================================================


// ===================================================================

// User

// optional int32 uid = 1;
inline bool User::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 User::uid() const {
  // @@protoc_insertion_point(field_get:dos.User.uid)
  return uid_;
}
inline void User::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:dos.User.uid)
}

// optional string name = 2;
inline bool User::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void User::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void User::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void User::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& User::name() const {
  // @@protoc_insertion_point(field_get:dos.User.name)
  return *name_;
}
inline void User::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:dos.User.name)
}
inline void User::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.User.name)
}
inline void User::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.User.name)
}
inline ::std::string* User::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.User.name)
  return name_;
}
inline ::std::string* User::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void User::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.User.name)
}

// optional int32 gid = 3;
inline bool User::has_gid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void User::set_has_gid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void User::clear_has_gid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void User::clear_gid() {
  gid_ = 0;
  clear_has_gid();
}
inline ::google::protobuf::int32 User::gid() const {
  // @@protoc_insertion_point(field_get:dos.User.gid)
  return gid_;
}
inline void User::set_gid(::google::protobuf::int32 value) {
  set_has_gid();
  gid_ = value;
  // @@protoc_insertion_point(field_set:dos.User.gid)
}

// optional uint64 ctime = 4;
inline bool User::has_ctime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void User::set_has_ctime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void User::clear_has_ctime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void User::clear_ctime() {
  ctime_ = GOOGLE_ULONGLONG(0);
  clear_has_ctime();
}
inline ::google::protobuf::uint64 User::ctime() const {
  // @@protoc_insertion_point(field_get:dos.User.ctime)
  return ctime_;
}
inline void User::set_ctime(::google::protobuf::uint64 value) {
  set_has_ctime();
  ctime_ = value;
  // @@protoc_insertion_point(field_set:dos.User.ctime)
}

// optional string home = 5;
inline bool User::has_home() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void User::set_has_home() {
  _has_bits_[0] |= 0x00000010u;
}
inline void User::clear_has_home() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void User::clear_home() {
  if (home_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    home_->clear();
  }
  clear_has_home();
}
inline const ::std::string& User::home() const {
  // @@protoc_insertion_point(field_get:dos.User.home)
  return *home_;
}
inline void User::set_home(const ::std::string& value) {
  set_has_home();
  if (home_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    home_ = new ::std::string;
  }
  home_->assign(value);
  // @@protoc_insertion_point(field_set:dos.User.home)
}
inline void User::set_home(const char* value) {
  set_has_home();
  if (home_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    home_ = new ::std::string;
  }
  home_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.User.home)
}
inline void User::set_home(const char* value, size_t size) {
  set_has_home();
  if (home_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    home_ = new ::std::string;
  }
  home_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.User.home)
}
inline ::std::string* User::mutable_home() {
  set_has_home();
  if (home_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    home_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.User.home)
  return home_;
}
inline ::std::string* User::release_home() {
  clear_has_home();
  if (home_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = home_;
    home_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void User::set_allocated_home(::std::string* home) {
  if (home_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete home_;
  }
  if (home) {
    set_has_home();
    home_ = home;
  } else {
    clear_has_home();
    home_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.User.home)
}

// -------------------------------------------------------------------

// Group

// optional int32 gid = 1;
inline bool Group::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Group::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Group::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Group::clear_gid() {
  gid_ = 0;
  clear_has_gid();
}
inline ::google::protobuf::int32 Group::gid() const {
  // @@protoc_insertion_point(field_get:dos.Group.gid)
  return gid_;
}
inline void Group::set_gid(::google::protobuf::int32 value) {
  set_has_gid();
  gid_ = value;
  // @@protoc_insertion_point(field_set:dos.Group.gid)
}

// optional string name = 2;
inline bool Group::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Group::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Group::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Group::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Group::name() const {
  // @@protoc_insertion_point(field_get:dos.Group.name)
  return *name_;
}
inline void Group::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:dos.Group.name)
}
inline void Group::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.Group.name)
}
inline void Group::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.Group.name)
}
inline ::std::string* Group::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.Group.name)
  return name_;
}
inline ::std::string* Group::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Group::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Group.name)
}

// optional uint64 ctime = 3;
inline bool Group::has_ctime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Group::set_has_ctime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Group::clear_has_ctime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Group::clear_ctime() {
  ctime_ = GOOGLE_ULONGLONG(0);
  clear_has_ctime();
}
inline ::google::protobuf::uint64 Group::ctime() const {
  // @@protoc_insertion_point(field_get:dos.Group.ctime)
  return ctime_;
}
inline void Group::set_ctime(::google::protobuf::uint64 value) {
  set_has_ctime();
  ctime_ = value;
  // @@protoc_insertion_point(field_set:dos.Group.ctime)
}

// -------------------------------------------------------------------

// Cpu

// optional uint64 limit = 1;
inline bool Cpu::has_limit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cpu::set_has_limit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cpu::clear_has_limit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cpu::clear_limit() {
  limit_ = GOOGLE_ULONGLONG(0);
  clear_has_limit();
}
inline ::google::protobuf::uint64 Cpu::limit() const {
  // @@protoc_insertion_point(field_get:dos.Cpu.limit)
  return limit_;
}
inline void Cpu::set_limit(::google::protobuf::uint64 value) {
  set_has_limit();
  limit_ = value;
  // @@protoc_insertion_point(field_set:dos.Cpu.limit)
}

// optional uint64 share = 2;
inline bool Cpu::has_share() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Cpu::set_has_share() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Cpu::clear_has_share() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Cpu::clear_share() {
  share_ = GOOGLE_ULONGLONG(0);
  clear_has_share();
}
inline ::google::protobuf::uint64 Cpu::share() const {
  // @@protoc_insertion_point(field_get:dos.Cpu.share)
  return share_;
}
inline void Cpu::set_share(::google::protobuf::uint64 value) {
  set_has_share();
  share_ = value;
  // @@protoc_insertion_point(field_set:dos.Cpu.share)
}

// optional uint64 used = 3;
inline bool Cpu::has_used() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Cpu::set_has_used() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Cpu::clear_has_used() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Cpu::clear_used() {
  used_ = GOOGLE_ULONGLONG(0);
  clear_has_used();
}
inline ::google::protobuf::uint64 Cpu::used() const {
  // @@protoc_insertion_point(field_get:dos.Cpu.used)
  return used_;
}
inline void Cpu::set_used(::google::protobuf::uint64 value) {
  set_has_used();
  used_ = value;
  // @@protoc_insertion_point(field_set:dos.Cpu.used)
}

// optional uint64 assigned = 4;
inline bool Cpu::has_assigned() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Cpu::set_has_assigned() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Cpu::clear_has_assigned() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Cpu::clear_assigned() {
  assigned_ = GOOGLE_ULONGLONG(0);
  clear_has_assigned();
}
inline ::google::protobuf::uint64 Cpu::assigned() const {
  // @@protoc_insertion_point(field_get:dos.Cpu.assigned)
  return assigned_;
}
inline void Cpu::set_assigned(::google::protobuf::uint64 value) {
  set_has_assigned();
  assigned_ = value;
  // @@protoc_insertion_point(field_set:dos.Cpu.assigned)
}

// -------------------------------------------------------------------

// Memory

// optional uint64 limit = 1;
inline bool Memory::has_limit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Memory::set_has_limit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Memory::clear_has_limit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Memory::clear_limit() {
  limit_ = GOOGLE_ULONGLONG(0);
  clear_has_limit();
}
inline ::google::protobuf::uint64 Memory::limit() const {
  // @@protoc_insertion_point(field_get:dos.Memory.limit)
  return limit_;
}
inline void Memory::set_limit(::google::protobuf::uint64 value) {
  set_has_limit();
  limit_ = value;
  // @@protoc_insertion_point(field_set:dos.Memory.limit)
}

// optional uint64 used = 2;
inline bool Memory::has_used() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Memory::set_has_used() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Memory::clear_has_used() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Memory::clear_used() {
  used_ = GOOGLE_ULONGLONG(0);
  clear_has_used();
}
inline ::google::protobuf::uint64 Memory::used() const {
  // @@protoc_insertion_point(field_get:dos.Memory.used)
  return used_;
}
inline void Memory::set_used(::google::protobuf::uint64 value) {
  set_has_used();
  used_ = value;
  // @@protoc_insertion_point(field_set:dos.Memory.used)
}

// optional uint64 assigned = 3;
inline bool Memory::has_assigned() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Memory::set_has_assigned() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Memory::clear_has_assigned() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Memory::clear_assigned() {
  assigned_ = GOOGLE_ULONGLONG(0);
  clear_has_assigned();
}
inline ::google::protobuf::uint64 Memory::assigned() const {
  // @@protoc_insertion_point(field_get:dos.Memory.assigned)
  return assigned_;
}
inline void Memory::set_assigned(::google::protobuf::uint64 value) {
  set_has_assigned();
  assigned_ = value;
  // @@protoc_insertion_point(field_set:dos.Memory.assigned)
}

// -------------------------------------------------------------------

// Range

// optional uint32 start = 1;
inline bool Range::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Range::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Range::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Range::clear_start() {
  start_ = 0u;
  clear_has_start();
}
inline ::google::protobuf::uint32 Range::start() const {
  // @@protoc_insertion_point(field_get:dos.Range.start)
  return start_;
}
inline void Range::set_start(::google::protobuf::uint32 value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:dos.Range.start)
}

// optional uint32 end = 2;
inline bool Range::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Range::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Range::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Range::clear_end() {
  end_ = 0u;
  clear_has_end();
}
inline ::google::protobuf::uint32 Range::end() const {
  // @@protoc_insertion_point(field_get:dos.Range.end)
  return end_;
}
inline void Range::set_end(::google::protobuf::uint32 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:dos.Range.end)
}

// -------------------------------------------------------------------

// Port

// optional .dos.Range range = 1;
inline bool Port::has_range() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Port::set_has_range() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Port::clear_has_range() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Port::clear_range() {
  if (range_ != NULL) range_->::dos::Range::Clear();
  clear_has_range();
}
inline const ::dos::Range& Port::range() const {
  // @@protoc_insertion_point(field_get:dos.Port.range)
  return range_ != NULL ? *range_ : *default_instance_->range_;
}
inline ::dos::Range* Port::mutable_range() {
  set_has_range();
  if (range_ == NULL) range_ = new ::dos::Range;
  // @@protoc_insertion_point(field_mutable:dos.Port.range)
  return range_;
}
inline ::dos::Range* Port::release_range() {
  clear_has_range();
  ::dos::Range* temp = range_;
  range_ = NULL;
  return temp;
}
inline void Port::set_allocated_range(::dos::Range* range) {
  delete range_;
  range_ = range;
  if (range) {
    set_has_range();
  } else {
    clear_has_range();
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Port.range)
}

// repeated uint32 assigned = 2;
inline int Port::assigned_size() const {
  return assigned_.size();
}
inline void Port::clear_assigned() {
  assigned_.Clear();
}
inline ::google::protobuf::uint32 Port::assigned(int index) const {
  // @@protoc_insertion_point(field_get:dos.Port.assigned)
  return assigned_.Get(index);
}
inline void Port::set_assigned(int index, ::google::protobuf::uint32 value) {
  assigned_.Set(index, value);
  // @@protoc_insertion_point(field_set:dos.Port.assigned)
}
inline void Port::add_assigned(::google::protobuf::uint32 value) {
  assigned_.Add(value);
  // @@protoc_insertion_point(field_add:dos.Port.assigned)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Port::assigned() const {
  // @@protoc_insertion_point(field_list:dos.Port.assigned)
  return assigned_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Port::mutable_assigned() {
  // @@protoc_insertion_point(field_mutable_list:dos.Port.assigned)
  return &assigned_;
}

// -------------------------------------------------------------------

// Network

// optional uint32 out_bytes_ps_limit = 1;
inline bool Network::has_out_bytes_ps_limit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Network::set_has_out_bytes_ps_limit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Network::clear_has_out_bytes_ps_limit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Network::clear_out_bytes_ps_limit() {
  out_bytes_ps_limit_ = 0u;
  clear_has_out_bytes_ps_limit();
}
inline ::google::protobuf::uint32 Network::out_bytes_ps_limit() const {
  // @@protoc_insertion_point(field_get:dos.Network.out_bytes_ps_limit)
  return out_bytes_ps_limit_;
}
inline void Network::set_out_bytes_ps_limit(::google::protobuf::uint32 value) {
  set_has_out_bytes_ps_limit();
  out_bytes_ps_limit_ = value;
  // @@protoc_insertion_point(field_set:dos.Network.out_bytes_ps_limit)
}

// optional uint32 out_bytes_ps_used = 2;
inline bool Network::has_out_bytes_ps_used() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Network::set_has_out_bytes_ps_used() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Network::clear_has_out_bytes_ps_used() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Network::clear_out_bytes_ps_used() {
  out_bytes_ps_used_ = 0u;
  clear_has_out_bytes_ps_used();
}
inline ::google::protobuf::uint32 Network::out_bytes_ps_used() const {
  // @@protoc_insertion_point(field_get:dos.Network.out_bytes_ps_used)
  return out_bytes_ps_used_;
}
inline void Network::set_out_bytes_ps_used(::google::protobuf::uint32 value) {
  set_has_out_bytes_ps_used();
  out_bytes_ps_used_ = value;
  // @@protoc_insertion_point(field_set:dos.Network.out_bytes_ps_used)
}

// optional uint32 out_bytes_ps_assigned = 3;
inline bool Network::has_out_bytes_ps_assigned() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Network::set_has_out_bytes_ps_assigned() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Network::clear_has_out_bytes_ps_assigned() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Network::clear_out_bytes_ps_assigned() {
  out_bytes_ps_assigned_ = 0u;
  clear_has_out_bytes_ps_assigned();
}
inline ::google::protobuf::uint32 Network::out_bytes_ps_assigned() const {
  // @@protoc_insertion_point(field_get:dos.Network.out_bytes_ps_assigned)
  return out_bytes_ps_assigned_;
}
inline void Network::set_out_bytes_ps_assigned(::google::protobuf::uint32 value) {
  set_has_out_bytes_ps_assigned();
  out_bytes_ps_assigned_ = value;
  // @@protoc_insertion_point(field_set:dos.Network.out_bytes_ps_assigned)
}

// optional uint32 in_bytes_ps_limit = 4;
inline bool Network::has_in_bytes_ps_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Network::set_has_in_bytes_ps_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Network::clear_has_in_bytes_ps_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Network::clear_in_bytes_ps_limit() {
  in_bytes_ps_limit_ = 0u;
  clear_has_in_bytes_ps_limit();
}
inline ::google::protobuf::uint32 Network::in_bytes_ps_limit() const {
  // @@protoc_insertion_point(field_get:dos.Network.in_bytes_ps_limit)
  return in_bytes_ps_limit_;
}
inline void Network::set_in_bytes_ps_limit(::google::protobuf::uint32 value) {
  set_has_in_bytes_ps_limit();
  in_bytes_ps_limit_ = value;
  // @@protoc_insertion_point(field_set:dos.Network.in_bytes_ps_limit)
}

// optional uint32 in_bytes_ps_used = 5;
inline bool Network::has_in_bytes_ps_used() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Network::set_has_in_bytes_ps_used() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Network::clear_has_in_bytes_ps_used() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Network::clear_in_bytes_ps_used() {
  in_bytes_ps_used_ = 0u;
  clear_has_in_bytes_ps_used();
}
inline ::google::protobuf::uint32 Network::in_bytes_ps_used() const {
  // @@protoc_insertion_point(field_get:dos.Network.in_bytes_ps_used)
  return in_bytes_ps_used_;
}
inline void Network::set_in_bytes_ps_used(::google::protobuf::uint32 value) {
  set_has_in_bytes_ps_used();
  in_bytes_ps_used_ = value;
  // @@protoc_insertion_point(field_set:dos.Network.in_bytes_ps_used)
}

// optional uint32 in_bytes_ps_assigned = 6;
inline bool Network::has_in_bytes_ps_assigned() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Network::set_has_in_bytes_ps_assigned() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Network::clear_has_in_bytes_ps_assigned() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Network::clear_in_bytes_ps_assigned() {
  in_bytes_ps_assigned_ = 0u;
  clear_has_in_bytes_ps_assigned();
}
inline ::google::protobuf::uint32 Network::in_bytes_ps_assigned() const {
  // @@protoc_insertion_point(field_get:dos.Network.in_bytes_ps_assigned)
  return in_bytes_ps_assigned_;
}
inline void Network::set_in_bytes_ps_assigned(::google::protobuf::uint32 value) {
  set_has_in_bytes_ps_assigned();
  in_bytes_ps_assigned_ = value;
  // @@protoc_insertion_point(field_set:dos.Network.in_bytes_ps_assigned)
}

// -------------------------------------------------------------------

// DiskIO

// optional uint32 read_bytes_ps_limit = 1;
inline bool DiskIO::has_read_bytes_ps_limit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiskIO::set_has_read_bytes_ps_limit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiskIO::clear_has_read_bytes_ps_limit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiskIO::clear_read_bytes_ps_limit() {
  read_bytes_ps_limit_ = 0u;
  clear_has_read_bytes_ps_limit();
}
inline ::google::protobuf::uint32 DiskIO::read_bytes_ps_limit() const {
  // @@protoc_insertion_point(field_get:dos.DiskIO.read_bytes_ps_limit)
  return read_bytes_ps_limit_;
}
inline void DiskIO::set_read_bytes_ps_limit(::google::protobuf::uint32 value) {
  set_has_read_bytes_ps_limit();
  read_bytes_ps_limit_ = value;
  // @@protoc_insertion_point(field_set:dos.DiskIO.read_bytes_ps_limit)
}

// optional uint32 read_bytes_ps_used = 2;
inline bool DiskIO::has_read_bytes_ps_used() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiskIO::set_has_read_bytes_ps_used() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiskIO::clear_has_read_bytes_ps_used() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiskIO::clear_read_bytes_ps_used() {
  read_bytes_ps_used_ = 0u;
  clear_has_read_bytes_ps_used();
}
inline ::google::protobuf::uint32 DiskIO::read_bytes_ps_used() const {
  // @@protoc_insertion_point(field_get:dos.DiskIO.read_bytes_ps_used)
  return read_bytes_ps_used_;
}
inline void DiskIO::set_read_bytes_ps_used(::google::protobuf::uint32 value) {
  set_has_read_bytes_ps_used();
  read_bytes_ps_used_ = value;
  // @@protoc_insertion_point(field_set:dos.DiskIO.read_bytes_ps_used)
}

// optional uint32 read_bytes_ps_assigned = 3;
inline bool DiskIO::has_read_bytes_ps_assigned() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DiskIO::set_has_read_bytes_ps_assigned() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DiskIO::clear_has_read_bytes_ps_assigned() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DiskIO::clear_read_bytes_ps_assigned() {
  read_bytes_ps_assigned_ = 0u;
  clear_has_read_bytes_ps_assigned();
}
inline ::google::protobuf::uint32 DiskIO::read_bytes_ps_assigned() const {
  // @@protoc_insertion_point(field_get:dos.DiskIO.read_bytes_ps_assigned)
  return read_bytes_ps_assigned_;
}
inline void DiskIO::set_read_bytes_ps_assigned(::google::protobuf::uint32 value) {
  set_has_read_bytes_ps_assigned();
  read_bytes_ps_assigned_ = value;
  // @@protoc_insertion_point(field_set:dos.DiskIO.read_bytes_ps_assigned)
}

// optional uint32 write_bytes_ps_limit = 4;
inline bool DiskIO::has_write_bytes_ps_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DiskIO::set_has_write_bytes_ps_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DiskIO::clear_has_write_bytes_ps_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DiskIO::clear_write_bytes_ps_limit() {
  write_bytes_ps_limit_ = 0u;
  clear_has_write_bytes_ps_limit();
}
inline ::google::protobuf::uint32 DiskIO::write_bytes_ps_limit() const {
  // @@protoc_insertion_point(field_get:dos.DiskIO.write_bytes_ps_limit)
  return write_bytes_ps_limit_;
}
inline void DiskIO::set_write_bytes_ps_limit(::google::protobuf::uint32 value) {
  set_has_write_bytes_ps_limit();
  write_bytes_ps_limit_ = value;
  // @@protoc_insertion_point(field_set:dos.DiskIO.write_bytes_ps_limit)
}

// optional uint32 write_bytes_ps_used = 5;
inline bool DiskIO::has_write_bytes_ps_used() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DiskIO::set_has_write_bytes_ps_used() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DiskIO::clear_has_write_bytes_ps_used() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DiskIO::clear_write_bytes_ps_used() {
  write_bytes_ps_used_ = 0u;
  clear_has_write_bytes_ps_used();
}
inline ::google::protobuf::uint32 DiskIO::write_bytes_ps_used() const {
  // @@protoc_insertion_point(field_get:dos.DiskIO.write_bytes_ps_used)
  return write_bytes_ps_used_;
}
inline void DiskIO::set_write_bytes_ps_used(::google::protobuf::uint32 value) {
  set_has_write_bytes_ps_used();
  write_bytes_ps_used_ = value;
  // @@protoc_insertion_point(field_set:dos.DiskIO.write_bytes_ps_used)
}

// optional uint32 write_bytes_ps_assigned = 6;
inline bool DiskIO::has_write_bytes_ps_assigned() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DiskIO::set_has_write_bytes_ps_assigned() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DiskIO::clear_has_write_bytes_ps_assigned() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DiskIO::clear_write_bytes_ps_assigned() {
  write_bytes_ps_assigned_ = 0u;
  clear_has_write_bytes_ps_assigned();
}
inline ::google::protobuf::uint32 DiskIO::write_bytes_ps_assigned() const {
  // @@protoc_insertion_point(field_get:dos.DiskIO.write_bytes_ps_assigned)
  return write_bytes_ps_assigned_;
}
inline void DiskIO::set_write_bytes_ps_assigned(::google::protobuf::uint32 value) {
  set_has_write_bytes_ps_assigned();
  write_bytes_ps_assigned_ = value;
  // @@protoc_insertion_point(field_set:dos.DiskIO.write_bytes_ps_assigned)
}

// optional string device = 7;
inline bool DiskIO::has_device() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DiskIO::set_has_device() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DiskIO::clear_has_device() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DiskIO::clear_device() {
  if (device_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_->clear();
  }
  clear_has_device();
}
inline const ::std::string& DiskIO::device() const {
  // @@protoc_insertion_point(field_get:dos.DiskIO.device)
  return *device_;
}
inline void DiskIO::set_device(const ::std::string& value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_ = new ::std::string;
  }
  device_->assign(value);
  // @@protoc_insertion_point(field_set:dos.DiskIO.device)
}
inline void DiskIO::set_device(const char* value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_ = new ::std::string;
  }
  device_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.DiskIO.device)
}
inline void DiskIO::set_device(const char* value, size_t size) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_ = new ::std::string;
  }
  device_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.DiskIO.device)
}
inline ::std::string* DiskIO::mutable_device() {
  set_has_device();
  if (device_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.DiskIO.device)
  return device_;
}
inline ::std::string* DiskIO::release_device() {
  clear_has_device();
  if (device_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = device_;
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DiskIO::set_allocated_device(::std::string* device) {
  if (device_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete device_;
  }
  if (device) {
    set_has_device();
    device_ = device;
  } else {
    clear_has_device();
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.DiskIO.device)
}

// -------------------------------------------------------------------

// Resource

// optional .dos.Cpu cpu = 1;
inline bool Resource::has_cpu() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource::set_has_cpu() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource::clear_has_cpu() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource::clear_cpu() {
  if (cpu_ != NULL) cpu_->::dos::Cpu::Clear();
  clear_has_cpu();
}
inline const ::dos::Cpu& Resource::cpu() const {
  // @@protoc_insertion_point(field_get:dos.Resource.cpu)
  return cpu_ != NULL ? *cpu_ : *default_instance_->cpu_;
}
inline ::dos::Cpu* Resource::mutable_cpu() {
  set_has_cpu();
  if (cpu_ == NULL) cpu_ = new ::dos::Cpu;
  // @@protoc_insertion_point(field_mutable:dos.Resource.cpu)
  return cpu_;
}
inline ::dos::Cpu* Resource::release_cpu() {
  clear_has_cpu();
  ::dos::Cpu* temp = cpu_;
  cpu_ = NULL;
  return temp;
}
inline void Resource::set_allocated_cpu(::dos::Cpu* cpu) {
  delete cpu_;
  cpu_ = cpu;
  if (cpu) {
    set_has_cpu();
  } else {
    clear_has_cpu();
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Resource.cpu)
}

// optional .dos.Memory memory = 2;
inline bool Resource::has_memory() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Resource::set_has_memory() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Resource::clear_has_memory() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Resource::clear_memory() {
  if (memory_ != NULL) memory_->::dos::Memory::Clear();
  clear_has_memory();
}
inline const ::dos::Memory& Resource::memory() const {
  // @@protoc_insertion_point(field_get:dos.Resource.memory)
  return memory_ != NULL ? *memory_ : *default_instance_->memory_;
}
inline ::dos::Memory* Resource::mutable_memory() {
  set_has_memory();
  if (memory_ == NULL) memory_ = new ::dos::Memory;
  // @@protoc_insertion_point(field_mutable:dos.Resource.memory)
  return memory_;
}
inline ::dos::Memory* Resource::release_memory() {
  clear_has_memory();
  ::dos::Memory* temp = memory_;
  memory_ = NULL;
  return temp;
}
inline void Resource::set_allocated_memory(::dos::Memory* memory) {
  delete memory_;
  memory_ = memory;
  if (memory) {
    set_has_memory();
  } else {
    clear_has_memory();
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Resource.memory)
}

// optional .dos.Port port = 3;
inline bool Resource::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Resource::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Resource::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Resource::clear_port() {
  if (port_ != NULL) port_->::dos::Port::Clear();
  clear_has_port();
}
inline const ::dos::Port& Resource::port() const {
  // @@protoc_insertion_point(field_get:dos.Resource.port)
  return port_ != NULL ? *port_ : *default_instance_->port_;
}
inline ::dos::Port* Resource::mutable_port() {
  set_has_port();
  if (port_ == NULL) port_ = new ::dos::Port;
  // @@protoc_insertion_point(field_mutable:dos.Resource.port)
  return port_;
}
inline ::dos::Port* Resource::release_port() {
  clear_has_port();
  ::dos::Port* temp = port_;
  port_ = NULL;
  return temp;
}
inline void Resource::set_allocated_port(::dos::Port* port) {
  delete port_;
  port_ = port;
  if (port) {
    set_has_port();
  } else {
    clear_has_port();
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Resource.port)
}

// optional .dos.Network network = 4;
inline bool Resource::has_network() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Resource::set_has_network() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Resource::clear_has_network() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Resource::clear_network() {
  if (network_ != NULL) network_->::dos::Network::Clear();
  clear_has_network();
}
inline const ::dos::Network& Resource::network() const {
  // @@protoc_insertion_point(field_get:dos.Resource.network)
  return network_ != NULL ? *network_ : *default_instance_->network_;
}
inline ::dos::Network* Resource::mutable_network() {
  set_has_network();
  if (network_ == NULL) network_ = new ::dos::Network;
  // @@protoc_insertion_point(field_mutable:dos.Resource.network)
  return network_;
}
inline ::dos::Network* Resource::release_network() {
  clear_has_network();
  ::dos::Network* temp = network_;
  network_ = NULL;
  return temp;
}
inline void Resource::set_allocated_network(::dos::Network* network) {
  delete network_;
  network_ = network;
  if (network) {
    set_has_network();
  } else {
    clear_has_network();
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Resource.network)
}

// repeated .dos.DiskIO diskio = 5;
inline int Resource::diskio_size() const {
  return diskio_.size();
}
inline void Resource::clear_diskio() {
  diskio_.Clear();
}
inline const ::dos::DiskIO& Resource::diskio(int index) const {
  // @@protoc_insertion_point(field_get:dos.Resource.diskio)
  return diskio_.Get(index);
}
inline ::dos::DiskIO* Resource::mutable_diskio(int index) {
  // @@protoc_insertion_point(field_mutable:dos.Resource.diskio)
  return diskio_.Mutable(index);
}
inline ::dos::DiskIO* Resource::add_diskio() {
  // @@protoc_insertion_point(field_add:dos.Resource.diskio)
  return diskio_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dos::DiskIO >&
Resource::diskio() const {
  // @@protoc_insertion_point(field_list:dos.Resource.diskio)
  return diskio_;
}
inline ::google::protobuf::RepeatedPtrField< ::dos::DiskIO >*
Resource::mutable_diskio() {
  // @@protoc_insertion_point(field_mutable_list:dos.Resource.diskio)
  return &diskio_;
}

// optional uint64 gtime = 6;
inline bool Resource::has_gtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Resource::set_has_gtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Resource::clear_has_gtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Resource::clear_gtime() {
  gtime_ = GOOGLE_ULONGLONG(0);
  clear_has_gtime();
}
inline ::google::protobuf::uint64 Resource::gtime() const {
  // @@protoc_insertion_point(field_get:dos.Resource.gtime)
  return gtime_;
}
inline void Resource::set_gtime(::google::protobuf::uint64 value) {
  set_has_gtime();
  gtime_ = value;
  // @@protoc_insertion_point(field_set:dos.Resource.gtime)
}

// -------------------------------------------------------------------

// Process

// repeated string args = 1;
inline int Process::args_size() const {
  return args_.size();
}
inline void Process::clear_args() {
  args_.Clear();
}
inline const ::std::string& Process::args(int index) const {
  // @@protoc_insertion_point(field_get:dos.Process.args)
  return args_.Get(index);
}
inline ::std::string* Process::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:dos.Process.args)
  return args_.Mutable(index);
}
inline void Process::set_args(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:dos.Process.args)
  args_.Mutable(index)->assign(value);
}
inline void Process::set_args(int index, const char* value) {
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.Process.args)
}
inline void Process::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.Process.args)
}
inline ::std::string* Process::add_args() {
  return args_.Add();
}
inline void Process::add_args(const ::std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dos.Process.args)
}
inline void Process::add_args(const char* value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dos.Process.args)
}
inline void Process::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dos.Process.args)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Process::args() const {
  // @@protoc_insertion_point(field_list:dos.Process.args)
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Process::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:dos.Process.args)
  return &args_;
}

// optional .dos.User user = 2;
inline bool Process::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Process::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Process::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Process::clear_user() {
  if (user_ != NULL) user_->::dos::User::Clear();
  clear_has_user();
}
inline const ::dos::User& Process::user() const {
  // @@protoc_insertion_point(field_get:dos.Process.user)
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::dos::User* Process::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::dos::User;
  // @@protoc_insertion_point(field_mutable:dos.Process.user)
  return user_;
}
inline ::dos::User* Process::release_user() {
  clear_has_user();
  ::dos::User* temp = user_;
  user_ = NULL;
  return temp;
}
inline void Process::set_allocated_user(::dos::User* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Process.user)
}

// repeated string envs = 3;
inline int Process::envs_size() const {
  return envs_.size();
}
inline void Process::clear_envs() {
  envs_.Clear();
}
inline const ::std::string& Process::envs(int index) const {
  // @@protoc_insertion_point(field_get:dos.Process.envs)
  return envs_.Get(index);
}
inline ::std::string* Process::mutable_envs(int index) {
  // @@protoc_insertion_point(field_mutable:dos.Process.envs)
  return envs_.Mutable(index);
}
inline void Process::set_envs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:dos.Process.envs)
  envs_.Mutable(index)->assign(value);
}
inline void Process::set_envs(int index, const char* value) {
  envs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.Process.envs)
}
inline void Process::set_envs(int index, const char* value, size_t size) {
  envs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.Process.envs)
}
inline ::std::string* Process::add_envs() {
  return envs_.Add();
}
inline void Process::add_envs(const ::std::string& value) {
  envs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dos.Process.envs)
}
inline void Process::add_envs(const char* value) {
  envs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dos.Process.envs)
}
inline void Process::add_envs(const char* value, size_t size) {
  envs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dos.Process.envs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Process::envs() const {
  // @@protoc_insertion_point(field_list:dos.Process.envs)
  return envs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Process::mutable_envs() {
  // @@protoc_insertion_point(field_mutable_list:dos.Process.envs)
  return &envs_;
}

// optional string cwd = 4;
inline bool Process::has_cwd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Process::set_has_cwd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Process::clear_has_cwd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Process::clear_cwd() {
  if (cwd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cwd_->clear();
  }
  clear_has_cwd();
}
inline const ::std::string& Process::cwd() const {
  // @@protoc_insertion_point(field_get:dos.Process.cwd)
  return *cwd_;
}
inline void Process::set_cwd(const ::std::string& value) {
  set_has_cwd();
  if (cwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cwd_ = new ::std::string;
  }
  cwd_->assign(value);
  // @@protoc_insertion_point(field_set:dos.Process.cwd)
}
inline void Process::set_cwd(const char* value) {
  set_has_cwd();
  if (cwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cwd_ = new ::std::string;
  }
  cwd_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.Process.cwd)
}
inline void Process::set_cwd(const char* value, size_t size) {
  set_has_cwd();
  if (cwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cwd_ = new ::std::string;
  }
  cwd_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.Process.cwd)
}
inline ::std::string* Process::mutable_cwd() {
  set_has_cwd();
  if (cwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cwd_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.Process.cwd)
  return cwd_;
}
inline ::std::string* Process::release_cwd() {
  clear_has_cwd();
  if (cwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cwd_;
    cwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Process::set_allocated_cwd(::std::string* cwd) {
  if (cwd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cwd_;
  }
  if (cwd) {
    set_has_cwd();
    cwd_ = cwd;
  } else {
    clear_has_cwd();
    cwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Process.cwd)
}

// optional string pty = 5;
inline bool Process::has_pty() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Process::set_has_pty() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Process::clear_has_pty() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Process::clear_pty() {
  if (pty_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pty_->clear();
  }
  clear_has_pty();
}
inline const ::std::string& Process::pty() const {
  // @@protoc_insertion_point(field_get:dos.Process.pty)
  return *pty_;
}
inline void Process::set_pty(const ::std::string& value) {
  set_has_pty();
  if (pty_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pty_ = new ::std::string;
  }
  pty_->assign(value);
  // @@protoc_insertion_point(field_set:dos.Process.pty)
}
inline void Process::set_pty(const char* value) {
  set_has_pty();
  if (pty_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pty_ = new ::std::string;
  }
  pty_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.Process.pty)
}
inline void Process::set_pty(const char* value, size_t size) {
  set_has_pty();
  if (pty_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pty_ = new ::std::string;
  }
  pty_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.Process.pty)
}
inline ::std::string* Process::mutable_pty() {
  set_has_pty();
  if (pty_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pty_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.Process.pty)
  return pty_;
}
inline ::std::string* Process::release_pty() {
  clear_has_pty();
  if (pty_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pty_;
    pty_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Process::set_allocated_pty(::std::string* pty) {
  if (pty_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pty_;
  }
  if (pty) {
    set_has_pty();
    pty_ = pty;
  } else {
    clear_has_pty();
    pty_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Process.pty)
}

// optional bool running = 6;
inline bool Process::has_running() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Process::set_has_running() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Process::clear_has_running() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Process::clear_running() {
  running_ = false;
  clear_has_running();
}
inline bool Process::running() const {
  // @@protoc_insertion_point(field_get:dos.Process.running)
  return running_;
}
inline void Process::set_running(bool value) {
  set_has_running();
  running_ = value;
  // @@protoc_insertion_point(field_set:dos.Process.running)
}

// optional int32 pid = 7;
inline bool Process::has_pid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Process::set_has_pid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Process::clear_has_pid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Process::clear_pid() {
  pid_ = 0;
  clear_has_pid();
}
inline ::google::protobuf::int32 Process::pid() const {
  // @@protoc_insertion_point(field_get:dos.Process.pid)
  return pid_;
}
inline void Process::set_pid(::google::protobuf::int32 value) {
  set_has_pid();
  pid_ = value;
  // @@protoc_insertion_point(field_set:dos.Process.pid)
}

// optional int32 gpid = 8;
inline bool Process::has_gpid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Process::set_has_gpid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Process::clear_has_gpid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Process::clear_gpid() {
  gpid_ = 0;
  clear_has_gpid();
}
inline ::google::protobuf::int32 Process::gpid() const {
  // @@protoc_insertion_point(field_get:dos.Process.gpid)
  return gpid_;
}
inline void Process::set_gpid(::google::protobuf::int32 value) {
  set_has_gpid();
  gpid_ = value;
  // @@protoc_insertion_point(field_set:dos.Process.gpid)
}

// optional int64 rtime = 9;
inline bool Process::has_rtime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Process::set_has_rtime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Process::clear_has_rtime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Process::clear_rtime() {
  rtime_ = GOOGLE_LONGLONG(0);
  clear_has_rtime();
}
inline ::google::protobuf::int64 Process::rtime() const {
  // @@protoc_insertion_point(field_get:dos.Process.rtime)
  return rtime_;
}
inline void Process::set_rtime(::google::protobuf::int64 value) {
  set_has_rtime();
  rtime_ = value;
  // @@protoc_insertion_point(field_set:dos.Process.rtime)
}

// optional bool coredump = 10;
inline bool Process::has_coredump() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Process::set_has_coredump() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Process::clear_has_coredump() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Process::clear_coredump() {
  coredump_ = false;
  clear_has_coredump();
}
inline bool Process::coredump() const {
  // @@protoc_insertion_point(field_get:dos.Process.coredump)
  return coredump_;
}
inline void Process::set_coredump(bool value) {
  set_has_coredump();
  coredump_ = value;
  // @@protoc_insertion_point(field_set:dos.Process.coredump)
}

// optional int32 exit_code = 11;
inline bool Process::has_exit_code() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Process::set_has_exit_code() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Process::clear_has_exit_code() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Process::clear_exit_code() {
  exit_code_ = 0;
  clear_has_exit_code();
}
inline ::google::protobuf::int32 Process::exit_code() const {
  // @@protoc_insertion_point(field_get:dos.Process.exit_code)
  return exit_code_;
}
inline void Process::set_exit_code(::google::protobuf::int32 value) {
  set_has_exit_code();
  exit_code_ = value;
  // @@protoc_insertion_point(field_set:dos.Process.exit_code)
}

// optional string name = 12;
inline bool Process::has_name() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Process::set_has_name() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Process::clear_has_name() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Process::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Process::name() const {
  // @@protoc_insertion_point(field_get:dos.Process.name)
  return *name_;
}
inline void Process::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:dos.Process.name)
}
inline void Process::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.Process.name)
}
inline void Process::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.Process.name)
}
inline ::std::string* Process::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.Process.name)
  return name_;
}
inline ::std::string* Process::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Process::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Process.name)
}

// optional bool terminal = 13;
inline bool Process::has_terminal() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Process::set_has_terminal() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Process::clear_has_terminal() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Process::clear_terminal() {
  terminal_ = false;
  clear_has_terminal();
}
inline bool Process::terminal() const {
  // @@protoc_insertion_point(field_get:dos.Process.terminal)
  return terminal_;
}
inline void Process::set_terminal(bool value) {
  set_has_terminal();
  terminal_ = value;
  // @@protoc_insertion_point(field_set:dos.Process.terminal)
}

// optional string interceptor = 14;
inline bool Process::has_interceptor() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Process::set_has_interceptor() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Process::clear_has_interceptor() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Process::clear_interceptor() {
  if (interceptor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interceptor_->clear();
  }
  clear_has_interceptor();
}
inline const ::std::string& Process::interceptor() const {
  // @@protoc_insertion_point(field_get:dos.Process.interceptor)
  return *interceptor_;
}
inline void Process::set_interceptor(const ::std::string& value) {
  set_has_interceptor();
  if (interceptor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interceptor_ = new ::std::string;
  }
  interceptor_->assign(value);
  // @@protoc_insertion_point(field_set:dos.Process.interceptor)
}
inline void Process::set_interceptor(const char* value) {
  set_has_interceptor();
  if (interceptor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interceptor_ = new ::std::string;
  }
  interceptor_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.Process.interceptor)
}
inline void Process::set_interceptor(const char* value, size_t size) {
  set_has_interceptor();
  if (interceptor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interceptor_ = new ::std::string;
  }
  interceptor_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.Process.interceptor)
}
inline ::std::string* Process::mutable_interceptor() {
  set_has_interceptor();
  if (interceptor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interceptor_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.Process.interceptor)
  return interceptor_;
}
inline ::std::string* Process::release_interceptor() {
  clear_has_interceptor();
  if (interceptor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = interceptor_;
    interceptor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Process::set_allocated_interceptor(::std::string* interceptor) {
  if (interceptor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete interceptor_;
  }
  if (interceptor) {
    set_has_interceptor();
    interceptor_ = interceptor;
  } else {
    clear_has_interceptor();
    interceptor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Process.interceptor)
}

// optional string hostname = 15;
inline bool Process::has_hostname() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Process::set_has_hostname() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Process::clear_has_hostname() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Process::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& Process::hostname() const {
  // @@protoc_insertion_point(field_get:dos.Process.hostname)
  return *hostname_;
}
inline void Process::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set:dos.Process.hostname)
}
inline void Process::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.Process.hostname)
}
inline void Process::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.Process.hostname)
}
inline ::std::string* Process::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.Process.hostname)
  return hostname_;
}
inline ::std::string* Process::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Process::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Process.hostname)
}

// -------------------------------------------------------------------

// Platform

// optional string os = 1;
inline bool Platform::has_os() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Platform::set_has_os() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Platform::clear_has_os() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Platform::clear_os() {
  if (os_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_->clear();
  }
  clear_has_os();
}
inline const ::std::string& Platform::os() const {
  // @@protoc_insertion_point(field_get:dos.Platform.os)
  return *os_;
}
inline void Platform::set_os(const ::std::string& value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_ = new ::std::string;
  }
  os_->assign(value);
  // @@protoc_insertion_point(field_set:dos.Platform.os)
}
inline void Platform::set_os(const char* value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_ = new ::std::string;
  }
  os_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.Platform.os)
}
inline void Platform::set_os(const char* value, size_t size) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_ = new ::std::string;
  }
  os_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.Platform.os)
}
inline ::std::string* Platform::mutable_os() {
  set_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.Platform.os)
  return os_;
}
inline ::std::string* Platform::release_os() {
  clear_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_;
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Platform::set_allocated_os(::std::string* os) {
  if (os_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_;
  }
  if (os) {
    set_has_os();
    os_ = os;
  } else {
    clear_has_os();
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Platform.os)
}

// optional string arch = 2;
inline bool Platform::has_arch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Platform::set_has_arch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Platform::clear_has_arch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Platform::clear_arch() {
  if (arch_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    arch_->clear();
  }
  clear_has_arch();
}
inline const ::std::string& Platform::arch() const {
  // @@protoc_insertion_point(field_get:dos.Platform.arch)
  return *arch_;
}
inline void Platform::set_arch(const ::std::string& value) {
  set_has_arch();
  if (arch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    arch_ = new ::std::string;
  }
  arch_->assign(value);
  // @@protoc_insertion_point(field_set:dos.Platform.arch)
}
inline void Platform::set_arch(const char* value) {
  set_has_arch();
  if (arch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    arch_ = new ::std::string;
  }
  arch_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.Platform.arch)
}
inline void Platform::set_arch(const char* value, size_t size) {
  set_has_arch();
  if (arch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    arch_ = new ::std::string;
  }
  arch_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.Platform.arch)
}
inline ::std::string* Platform::mutable_arch() {
  set_has_arch();
  if (arch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    arch_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.Platform.arch)
  return arch_;
}
inline ::std::string* Platform::release_arch() {
  clear_has_arch();
  if (arch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = arch_;
    arch_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Platform::set_allocated_arch(::std::string* arch) {
  if (arch_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete arch_;
  }
  if (arch) {
    set_has_arch();
    arch_ = arch;
  } else {
    clear_has_arch();
    arch_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Platform.arch)
}

// -------------------------------------------------------------------

// Root

// optional string path = 1;
inline bool Root::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Root::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Root::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Root::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& Root::path() const {
  // @@protoc_insertion_point(field_get:dos.Root.path)
  return *path_;
}
inline void Root::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:dos.Root.path)
}
inline void Root::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.Root.path)
}
inline void Root::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.Root.path)
}
inline ::std::string* Root::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.Root.path)
  return path_;
}
inline ::std::string* Root::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Root::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Root.path)
}

// optional bool readonly = 2;
inline bool Root::has_readonly() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Root::set_has_readonly() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Root::clear_has_readonly() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Root::clear_readonly() {
  readonly_ = false;
  clear_has_readonly();
}
inline bool Root::readonly() const {
  // @@protoc_insertion_point(field_get:dos.Root.readonly)
  return readonly_;
}
inline void Root::set_readonly(bool value) {
  set_has_readonly();
  readonly_ = value;
  // @@protoc_insertion_point(field_set:dos.Root.readonly)
}

// -------------------------------------------------------------------

// Mount

// optional string name = 1;
inline bool Mount::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mount::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mount::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mount::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Mount::name() const {
  // @@protoc_insertion_point(field_get:dos.Mount.name)
  return *name_;
}
inline void Mount::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:dos.Mount.name)
}
inline void Mount::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.Mount.name)
}
inline void Mount::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.Mount.name)
}
inline ::std::string* Mount::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.Mount.name)
  return name_;
}
inline ::std::string* Mount::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Mount::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Mount.name)
}

// optional string path = 2;
inline bool Mount::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mount::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mount::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mount::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& Mount::path() const {
  // @@protoc_insertion_point(field_get:dos.Mount.path)
  return *path_;
}
inline void Mount::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:dos.Mount.path)
}
inline void Mount::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.Mount.path)
}
inline void Mount::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.Mount.path)
}
inline ::std::string* Mount::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.Mount.path)
  return path_;
}
inline ::std::string* Mount::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Mount::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Mount.path)
}

// optional string type = 3;
inline bool Mount::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Mount::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Mount::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Mount::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& Mount::type() const {
  // @@protoc_insertion_point(field_get:dos.Mount.type)
  return *type_;
}
inline void Mount::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:dos.Mount.type)
}
inline void Mount::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.Mount.type)
}
inline void Mount::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.Mount.type)
}
inline ::std::string* Mount::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.Mount.type)
  return type_;
}
inline ::std::string* Mount::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Mount::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Mount.type)
}

// optional string source = 5;
inline bool Mount::has_source() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Mount::set_has_source() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Mount::clear_has_source() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Mount::clear_source() {
  if (source_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_->clear();
  }
  clear_has_source();
}
inline const ::std::string& Mount::source() const {
  // @@protoc_insertion_point(field_get:dos.Mount.source)
  return *source_;
}
inline void Mount::set_source(const ::std::string& value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(value);
  // @@protoc_insertion_point(field_set:dos.Mount.source)
}
inline void Mount::set_source(const char* value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.Mount.source)
}
inline void Mount::set_source(const char* value, size_t size) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.Mount.source)
}
inline ::std::string* Mount::mutable_source() {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.Mount.source)
  return source_;
}
inline ::std::string* Mount::release_source() {
  clear_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = source_;
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Mount::set_allocated_source(::std::string* source) {
  if (source_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete source_;
  }
  if (source) {
    set_has_source();
    source_ = source;
  } else {
    clear_has_source();
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Mount.source)
}

// optional string destination = 6;
inline bool Mount::has_destination() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Mount::set_has_destination() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Mount::clear_has_destination() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Mount::clear_destination() {
  if (destination_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    destination_->clear();
  }
  clear_has_destination();
}
inline const ::std::string& Mount::destination() const {
  // @@protoc_insertion_point(field_get:dos.Mount.destination)
  return *destination_;
}
inline void Mount::set_destination(const ::std::string& value) {
  set_has_destination();
  if (destination_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    destination_ = new ::std::string;
  }
  destination_->assign(value);
  // @@protoc_insertion_point(field_set:dos.Mount.destination)
}
inline void Mount::set_destination(const char* value) {
  set_has_destination();
  if (destination_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    destination_ = new ::std::string;
  }
  destination_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.Mount.destination)
}
inline void Mount::set_destination(const char* value, size_t size) {
  set_has_destination();
  if (destination_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    destination_ = new ::std::string;
  }
  destination_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.Mount.destination)
}
inline ::std::string* Mount::mutable_destination() {
  set_has_destination();
  if (destination_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    destination_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.Mount.destination)
  return destination_;
}
inline ::std::string* Mount::release_destination() {
  clear_has_destination();
  if (destination_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = destination_;
    destination_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Mount::set_allocated_destination(::std::string* destination) {
  if (destination_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete destination_;
  }
  if (destination) {
    set_has_destination();
    destination_ = destination;
  } else {
    clear_has_destination();
    destination_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Mount.destination)
}

// repeated string options = 7;
inline int Mount::options_size() const {
  return options_.size();
}
inline void Mount::clear_options() {
  options_.Clear();
}
inline const ::std::string& Mount::options(int index) const {
  // @@protoc_insertion_point(field_get:dos.Mount.options)
  return options_.Get(index);
}
inline ::std::string* Mount::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:dos.Mount.options)
  return options_.Mutable(index);
}
inline void Mount::set_options(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:dos.Mount.options)
  options_.Mutable(index)->assign(value);
}
inline void Mount::set_options(int index, const char* value) {
  options_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.Mount.options)
}
inline void Mount::set_options(int index, const char* value, size_t size) {
  options_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.Mount.options)
}
inline ::std::string* Mount::add_options() {
  return options_.Add();
}
inline void Mount::add_options(const ::std::string& value) {
  options_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dos.Mount.options)
}
inline void Mount::add_options(const char* value) {
  options_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dos.Mount.options)
}
inline void Mount::add_options(const char* value, size_t size) {
  options_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dos.Mount.options)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Mount::options() const {
  // @@protoc_insertion_point(field_list:dos.Mount.options)
  return options_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Mount::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:dos.Mount.options)
  return &options_;
}

// -------------------------------------------------------------------

// Device

// optional string path = 1;
inline bool Device::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Device::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Device::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Device::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& Device::path() const {
  // @@protoc_insertion_point(field_get:dos.Device.path)
  return *path_;
}
inline void Device::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:dos.Device.path)
}
inline void Device::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.Device.path)
}
inline void Device::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.Device.path)
}
inline ::std::string* Device::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.Device.path)
  return path_;
}
inline ::std::string* Device::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Device::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Device.path)
}

// optional int32 type = 2;
inline bool Device::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Device::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Device::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Device::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Device::type() const {
  // @@protoc_insertion_point(field_get:dos.Device.type)
  return type_;
}
inline void Device::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:dos.Device.type)
}

// optional int32 major = 3;
inline bool Device::has_major() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Device::set_has_major() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Device::clear_has_major() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Device::clear_major() {
  major_ = 0;
  clear_has_major();
}
inline ::google::protobuf::int32 Device::major() const {
  // @@protoc_insertion_point(field_get:dos.Device.major)
  return major_;
}
inline void Device::set_major(::google::protobuf::int32 value) {
  set_has_major();
  major_ = value;
  // @@protoc_insertion_point(field_set:dos.Device.major)
}

// optional int32 minor = 4;
inline bool Device::has_minor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Device::set_has_minor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Device::clear_has_minor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Device::clear_minor() {
  minor_ = 0;
  clear_has_minor();
}
inline ::google::protobuf::int32 Device::minor() const {
  // @@protoc_insertion_point(field_get:dos.Device.minor)
  return minor_;
}
inline void Device::set_minor(::google::protobuf::int32 value) {
  set_has_minor();
  minor_ = value;
  // @@protoc_insertion_point(field_set:dos.Device.minor)
}

// optional string permissions = 5;
inline bool Device::has_permissions() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Device::set_has_permissions() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Device::clear_has_permissions() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Device::clear_permissions() {
  if (permissions_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    permissions_->clear();
  }
  clear_has_permissions();
}
inline const ::std::string& Device::permissions() const {
  // @@protoc_insertion_point(field_get:dos.Device.permissions)
  return *permissions_;
}
inline void Device::set_permissions(const ::std::string& value) {
  set_has_permissions();
  if (permissions_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    permissions_ = new ::std::string;
  }
  permissions_->assign(value);
  // @@protoc_insertion_point(field_set:dos.Device.permissions)
}
inline void Device::set_permissions(const char* value) {
  set_has_permissions();
  if (permissions_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    permissions_ = new ::std::string;
  }
  permissions_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.Device.permissions)
}
inline void Device::set_permissions(const char* value, size_t size) {
  set_has_permissions();
  if (permissions_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    permissions_ = new ::std::string;
  }
  permissions_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.Device.permissions)
}
inline ::std::string* Device::mutable_permissions() {
  set_has_permissions();
  if (permissions_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    permissions_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.Device.permissions)
  return permissions_;
}
inline ::std::string* Device::release_permissions() {
  clear_has_permissions();
  if (permissions_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = permissions_;
    permissions_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Device::set_allocated_permissions(::std::string* permissions) {
  if (permissions_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete permissions_;
  }
  if (permissions) {
    set_has_permissions();
    permissions_ = permissions;
  } else {
    clear_has_permissions();
    permissions_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Device.permissions)
}

// optional int32 mode = 6;
inline bool Device::has_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Device::set_has_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Device::clear_has_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Device::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::google::protobuf::int32 Device::mode() const {
  // @@protoc_insertion_point(field_get:dos.Device.mode)
  return mode_;
}
inline void Device::set_mode(::google::protobuf::int32 value) {
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:dos.Device.mode)
}

// optional int32 uid = 7;
inline bool Device::has_uid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Device::set_has_uid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Device::clear_has_uid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Device::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 Device::uid() const {
  // @@protoc_insertion_point(field_get:dos.Device.uid)
  return uid_;
}
inline void Device::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:dos.Device.uid)
}

// optional int32 gid = 8;
inline bool Device::has_gid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Device::set_has_gid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Device::clear_has_gid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Device::clear_gid() {
  gid_ = 0;
  clear_has_gid();
}
inline ::google::protobuf::int32 Device::gid() const {
  // @@protoc_insertion_point(field_get:dos.Device.gid)
  return gid_;
}
inline void Device::set_gid(::google::protobuf::int32 value) {
  set_has_gid();
  gid_ = value;
  // @@protoc_insertion_point(field_set:dos.Device.gid)
}

// -------------------------------------------------------------------

// NodeMeta

// optional string ip = 1;
inline bool NodeMeta::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeMeta::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeMeta::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeMeta::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& NodeMeta::ip() const {
  // @@protoc_insertion_point(field_get:dos.NodeMeta.ip)
  return *ip_;
}
inline void NodeMeta::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:dos.NodeMeta.ip)
}
inline void NodeMeta::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.NodeMeta.ip)
}
inline void NodeMeta::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.NodeMeta.ip)
}
inline ::std::string* NodeMeta::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.NodeMeta.ip)
  return ip_;
}
inline ::std::string* NodeMeta::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NodeMeta::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.NodeMeta.ip)
}

// optional string hostname = 2;
inline bool NodeMeta::has_hostname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeMeta::set_has_hostname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeMeta::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeMeta::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& NodeMeta::hostname() const {
  // @@protoc_insertion_point(field_get:dos.NodeMeta.hostname)
  return *hostname_;
}
inline void NodeMeta::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set:dos.NodeMeta.hostname)
}
inline void NodeMeta::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.NodeMeta.hostname)
}
inline void NodeMeta::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.NodeMeta.hostname)
}
inline ::std::string* NodeMeta::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.NodeMeta.hostname)
  return hostname_;
}
inline ::std::string* NodeMeta::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NodeMeta::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.NodeMeta.hostname)
}

// optional string endpoint = 3;
inline bool NodeMeta::has_endpoint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeMeta::set_has_endpoint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeMeta::clear_has_endpoint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeMeta::clear_endpoint() {
  if (endpoint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    endpoint_->clear();
  }
  clear_has_endpoint();
}
inline const ::std::string& NodeMeta::endpoint() const {
  // @@protoc_insertion_point(field_get:dos.NodeMeta.endpoint)
  return *endpoint_;
}
inline void NodeMeta::set_endpoint(const ::std::string& value) {
  set_has_endpoint();
  if (endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    endpoint_ = new ::std::string;
  }
  endpoint_->assign(value);
  // @@protoc_insertion_point(field_set:dos.NodeMeta.endpoint)
}
inline void NodeMeta::set_endpoint(const char* value) {
  set_has_endpoint();
  if (endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    endpoint_ = new ::std::string;
  }
  endpoint_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.NodeMeta.endpoint)
}
inline void NodeMeta::set_endpoint(const char* value, size_t size) {
  set_has_endpoint();
  if (endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    endpoint_ = new ::std::string;
  }
  endpoint_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.NodeMeta.endpoint)
}
inline ::std::string* NodeMeta::mutable_endpoint() {
  set_has_endpoint();
  if (endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    endpoint_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.NodeMeta.endpoint)
  return endpoint_;
}
inline ::std::string* NodeMeta::release_endpoint() {
  clear_has_endpoint();
  if (endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = endpoint_;
    endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NodeMeta::set_allocated_endpoint(::std::string* endpoint) {
  if (endpoint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete endpoint_;
  }
  if (endpoint) {
    set_has_endpoint();
    endpoint_ = endpoint;
  } else {
    clear_has_endpoint();
    endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.NodeMeta.endpoint)
}

// optional .dos.Resource resource = 4;
inline bool NodeMeta::has_resource() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NodeMeta::set_has_resource() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NodeMeta::clear_has_resource() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NodeMeta::clear_resource() {
  if (resource_ != NULL) resource_->::dos::Resource::Clear();
  clear_has_resource();
}
inline const ::dos::Resource& NodeMeta::resource() const {
  // @@protoc_insertion_point(field_get:dos.NodeMeta.resource)
  return resource_ != NULL ? *resource_ : *default_instance_->resource_;
}
inline ::dos::Resource* NodeMeta::mutable_resource() {
  set_has_resource();
  if (resource_ == NULL) resource_ = new ::dos::Resource;
  // @@protoc_insertion_point(field_mutable:dos.NodeMeta.resource)
  return resource_;
}
inline ::dos::Resource* NodeMeta::release_resource() {
  clear_has_resource();
  ::dos::Resource* temp = resource_;
  resource_ = NULL;
  return temp;
}
inline void NodeMeta::set_allocated_resource(::dos::Resource* resource) {
  delete resource_;
  resource_ = resource;
  if (resource) {
    set_has_resource();
  } else {
    clear_has_resource();
  }
  // @@protoc_insertion_point(field_set_allocated:dos.NodeMeta.resource)
}

// -------------------------------------------------------------------

// Container

// optional .dos.Resource requirement = 1;
inline bool Container::has_requirement() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Container::set_has_requirement() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Container::clear_has_requirement() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Container::clear_requirement() {
  if (requirement_ != NULL) requirement_->::dos::Resource::Clear();
  clear_has_requirement();
}
inline const ::dos::Resource& Container::requirement() const {
  // @@protoc_insertion_point(field_get:dos.Container.requirement)
  return requirement_ != NULL ? *requirement_ : *default_instance_->requirement_;
}
inline ::dos::Resource* Container::mutable_requirement() {
  set_has_requirement();
  if (requirement_ == NULL) requirement_ = new ::dos::Resource;
  // @@protoc_insertion_point(field_mutable:dos.Container.requirement)
  return requirement_;
}
inline ::dos::Resource* Container::release_requirement() {
  clear_has_requirement();
  ::dos::Resource* temp = requirement_;
  requirement_ = NULL;
  return temp;
}
inline void Container::set_allocated_requirement(::dos::Resource* requirement) {
  delete requirement_;
  requirement_ = requirement;
  if (requirement) {
    set_has_requirement();
  } else {
    clear_has_requirement();
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Container.requirement)
}

// optional string image = 2;
inline bool Container::has_image() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Container::set_has_image() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Container::clear_has_image() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Container::clear_image() {
  if (image_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& Container::image() const {
  // @@protoc_insertion_point(field_get:dos.Container.image)
  return *image_;
}
inline void Container::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_ = new ::std::string;
  }
  image_->assign(value);
  // @@protoc_insertion_point(field_set:dos.Container.image)
}
inline void Container::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_ = new ::std::string;
  }
  image_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.Container.image)
}
inline void Container::set_image(const char* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.Container.image)
}
inline ::std::string* Container::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.Container.image)
  return image_;
}
inline ::std::string* Container::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Container::set_allocated_image(::std::string* image) {
  if (image_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete image_;
  }
  if (image) {
    set_has_image();
    image_ = image;
  } else {
    clear_has_image();
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Container.image)
}

// optional string tag = 3;
inline bool Container::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Container::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Container::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Container::clear_tag() {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& Container::tag() const {
  // @@protoc_insertion_point(field_get:dos.Container.tag)
  return *tag_;
}
inline void Container::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set:dos.Container.tag)
}
inline void Container::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.Container.tag)
}
inline void Container::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.Container.tag)
}
inline ::std::string* Container::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.Container.tag)
  return tag_;
}
inline ::std::string* Container::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Container::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Container.tag)
}

// optional string uri = 4;
inline bool Container::has_uri() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Container::set_has_uri() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Container::clear_has_uri() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Container::clear_uri() {
  if (uri_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_->clear();
  }
  clear_has_uri();
}
inline const ::std::string& Container::uri() const {
  // @@protoc_insertion_point(field_get:dos.Container.uri)
  return *uri_;
}
inline void Container::set_uri(const ::std::string& value) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
  // @@protoc_insertion_point(field_set:dos.Container.uri)
}
inline void Container::set_uri(const char* value) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.Container.uri)
}
inline void Container::set_uri(const char* value, size_t size) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_ = new ::std::string;
  }
  uri_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.Container.uri)
}
inline ::std::string* Container::mutable_uri() {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.Container.uri)
  return uri_;
}
inline ::std::string* Container::release_uri() {
  clear_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = uri_;
    uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Container::set_allocated_uri(::std::string* uri) {
  if (uri_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uri_;
  }
  if (uri) {
    set_has_uri();
    uri_ = uri;
  } else {
    clear_has_uri();
    uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.Container.uri)
}

// optional .dos.ContainerType type = 5;
inline bool Container::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Container::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Container::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Container::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::dos::ContainerType Container::type() const {
  // @@protoc_insertion_point(field_get:dos.Container.type)
  return static_cast< ::dos::ContainerType >(type_);
}
inline void Container::set_type(::dos::ContainerType value) {
  assert(::dos::ContainerType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:dos.Container.type)
}

// optional bool enable_ns = 6;
inline bool Container::has_enable_ns() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Container::set_has_enable_ns() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Container::clear_has_enable_ns() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Container::clear_enable_ns() {
  enable_ns_ = false;
  clear_has_enable_ns();
}
inline bool Container::enable_ns() const {
  // @@protoc_insertion_point(field_get:dos.Container.enable_ns)
  return enable_ns_;
}
inline void Container::set_enable_ns(bool value) {
  set_has_enable_ns();
  enable_ns_ = value;
  // @@protoc_insertion_point(field_set:dos.Container.enable_ns)
}

// optional int32 reserve_time = 7;
inline bool Container::has_reserve_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Container::set_has_reserve_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Container::clear_has_reserve_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Container::clear_reserve_time() {
  reserve_time_ = 0;
  clear_has_reserve_time();
}
inline ::google::protobuf::int32 Container::reserve_time() const {
  // @@protoc_insertion_point(field_get:dos.Container.reserve_time)
  return reserve_time_;
}
inline void Container::set_reserve_time(::google::protobuf::int32 value) {
  set_has_reserve_time();
  reserve_time_ = value;
  // @@protoc_insertion_point(field_set:dos.Container.reserve_time)
}

// optional .dos.RestartStrategy restart_strategy = 8;
inline bool Container::has_restart_strategy() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Container::set_has_restart_strategy() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Container::clear_has_restart_strategy() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Container::clear_restart_strategy() {
  restart_strategy_ = 0;
  clear_has_restart_strategy();
}
inline ::dos::RestartStrategy Container::restart_strategy() const {
  // @@protoc_insertion_point(field_get:dos.Container.restart_strategy)
  return static_cast< ::dos::RestartStrategy >(restart_strategy_);
}
inline void Container::set_restart_strategy(::dos::RestartStrategy value) {
  assert(::dos::RestartStrategy_IsValid(value));
  set_has_restart_strategy();
  restart_strategy_ = value;
  // @@protoc_insertion_point(field_set:dos.Container.restart_strategy)
}

// -------------------------------------------------------------------

// PodSpec

// repeated .dos.Container containers = 1;
inline int PodSpec::containers_size() const {
  return containers_.size();
}
inline void PodSpec::clear_containers() {
  containers_.Clear();
}
inline const ::dos::Container& PodSpec::containers(int index) const {
  // @@protoc_insertion_point(field_get:dos.PodSpec.containers)
  return containers_.Get(index);
}
inline ::dos::Container* PodSpec::mutable_containers(int index) {
  // @@protoc_insertion_point(field_mutable:dos.PodSpec.containers)
  return containers_.Mutable(index);
}
inline ::dos::Container* PodSpec::add_containers() {
  // @@protoc_insertion_point(field_add:dos.PodSpec.containers)
  return containers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dos::Container >&
PodSpec::containers() const {
  // @@protoc_insertion_point(field_list:dos.PodSpec.containers)
  return containers_;
}
inline ::google::protobuf::RepeatedPtrField< ::dos::Container >*
PodSpec::mutable_containers() {
  // @@protoc_insertion_point(field_mutable_list:dos.PodSpec.containers)
  return &containers_;
}

// optional int32 log_size = 2;
inline bool PodSpec::has_log_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PodSpec::set_has_log_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PodSpec::clear_has_log_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PodSpec::clear_log_size() {
  log_size_ = 0;
  clear_has_log_size();
}
inline ::google::protobuf::int32 PodSpec::log_size() const {
  // @@protoc_insertion_point(field_get:dos.PodSpec.log_size)
  return log_size_;
}
inline void PodSpec::set_log_size(::google::protobuf::int32 value) {
  set_has_log_size();
  log_size_ = value;
  // @@protoc_insertion_point(field_set:dos.PodSpec.log_size)
}

// optional .dos.PodType type = 3;
inline bool PodSpec::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PodSpec::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PodSpec::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PodSpec::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::dos::PodType PodSpec::type() const {
  // @@protoc_insertion_point(field_get:dos.PodSpec.type)
  return static_cast< ::dos::PodType >(type_);
}
inline void PodSpec::set_type(::dos::PodType value) {
  assert(::dos::PodType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:dos.PodSpec.type)
}

// -------------------------------------------------------------------

// JobSpec

// optional string name = 1;
inline bool JobSpec::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JobSpec::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JobSpec::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JobSpec::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& JobSpec::name() const {
  // @@protoc_insertion_point(field_get:dos.JobSpec.name)
  return *name_;
}
inline void JobSpec::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:dos.JobSpec.name)
}
inline void JobSpec::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.JobSpec.name)
}
inline void JobSpec::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.JobSpec.name)
}
inline ::std::string* JobSpec::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.JobSpec.name)
  return name_;
}
inline ::std::string* JobSpec::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void JobSpec::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.JobSpec.name)
}

// optional uint32 replica = 2;
inline bool JobSpec::has_replica() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JobSpec::set_has_replica() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JobSpec::clear_has_replica() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JobSpec::clear_replica() {
  replica_ = 0u;
  clear_has_replica();
}
inline ::google::protobuf::uint32 JobSpec::replica() const {
  // @@protoc_insertion_point(field_get:dos.JobSpec.replica)
  return replica_;
}
inline void JobSpec::set_replica(::google::protobuf::uint32 value) {
  set_has_replica();
  replica_ = value;
  // @@protoc_insertion_point(field_set:dos.JobSpec.replica)
}

// optional uint32 deploy_step_size = 3;
inline bool JobSpec::has_deploy_step_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JobSpec::set_has_deploy_step_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JobSpec::clear_has_deploy_step_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JobSpec::clear_deploy_step_size() {
  deploy_step_size_ = 0u;
  clear_has_deploy_step_size();
}
inline ::google::protobuf::uint32 JobSpec::deploy_step_size() const {
  // @@protoc_insertion_point(field_get:dos.JobSpec.deploy_step_size)
  return deploy_step_size_;
}
inline void JobSpec::set_deploy_step_size(::google::protobuf::uint32 value) {
  set_has_deploy_step_size();
  deploy_step_size_ = value;
  // @@protoc_insertion_point(field_set:dos.JobSpec.deploy_step_size)
}

// optional uint32 update_step_size = 4;
inline bool JobSpec::has_update_step_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JobSpec::set_has_update_step_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JobSpec::clear_has_update_step_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JobSpec::clear_update_step_size() {
  update_step_size_ = 0u;
  clear_has_update_step_size();
}
inline ::google::protobuf::uint32 JobSpec::update_step_size() const {
  // @@protoc_insertion_point(field_get:dos.JobSpec.update_step_size)
  return update_step_size_;
}
inline void JobSpec::set_update_step_size(::google::protobuf::uint32 value) {
  set_has_update_step_size();
  update_step_size_ = value;
  // @@protoc_insertion_point(field_set:dos.JobSpec.update_step_size)
}

// optional .dos.PodSpec pod = 5;
inline bool JobSpec::has_pod() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void JobSpec::set_has_pod() {
  _has_bits_[0] |= 0x00000010u;
}
inline void JobSpec::clear_has_pod() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void JobSpec::clear_pod() {
  if (pod_ != NULL) pod_->::dos::PodSpec::Clear();
  clear_has_pod();
}
inline const ::dos::PodSpec& JobSpec::pod() const {
  // @@protoc_insertion_point(field_get:dos.JobSpec.pod)
  return pod_ != NULL ? *pod_ : *default_instance_->pod_;
}
inline ::dos::PodSpec* JobSpec::mutable_pod() {
  set_has_pod();
  if (pod_ == NULL) pod_ = new ::dos::PodSpec;
  // @@protoc_insertion_point(field_mutable:dos.JobSpec.pod)
  return pod_;
}
inline ::dos::PodSpec* JobSpec::release_pod() {
  clear_has_pod();
  ::dos::PodSpec* temp = pod_;
  pod_ = NULL;
  return temp;
}
inline void JobSpec::set_allocated_pod(::dos::PodSpec* pod) {
  delete pod_;
  pod_ = pod;
  if (pod) {
    set_has_pod();
  } else {
    clear_has_pod();
  }
  // @@protoc_insertion_point(field_set_allocated:dos.JobSpec.pod)
}

// optional string version = 6;
inline bool JobSpec::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void JobSpec::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void JobSpec::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void JobSpec::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& JobSpec::version() const {
  // @@protoc_insertion_point(field_get:dos.JobSpec.version)
  return *version_;
}
inline void JobSpec::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:dos.JobSpec.version)
}
inline void JobSpec::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.JobSpec.version)
}
inline void JobSpec::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.JobSpec.version)
}
inline ::std::string* JobSpec::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.JobSpec.version)
  return version_;
}
inline ::std::string* JobSpec::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void JobSpec::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.JobSpec.version)
}

// optional bytes raw = 7;
inline bool JobSpec::has_raw() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void JobSpec::set_has_raw() {
  _has_bits_[0] |= 0x00000040u;
}
inline void JobSpec::clear_has_raw() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void JobSpec::clear_raw() {
  if (raw_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    raw_->clear();
  }
  clear_has_raw();
}
inline const ::std::string& JobSpec::raw() const {
  // @@protoc_insertion_point(field_get:dos.JobSpec.raw)
  return *raw_;
}
inline void JobSpec::set_raw(const ::std::string& value) {
  set_has_raw();
  if (raw_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    raw_ = new ::std::string;
  }
  raw_->assign(value);
  // @@protoc_insertion_point(field_set:dos.JobSpec.raw)
}
inline void JobSpec::set_raw(const char* value) {
  set_has_raw();
  if (raw_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    raw_ = new ::std::string;
  }
  raw_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.JobSpec.raw)
}
inline void JobSpec::set_raw(const void* value, size_t size) {
  set_has_raw();
  if (raw_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    raw_ = new ::std::string;
  }
  raw_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.JobSpec.raw)
}
inline ::std::string* JobSpec::mutable_raw() {
  set_has_raw();
  if (raw_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    raw_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.JobSpec.raw)
  return raw_;
}
inline ::std::string* JobSpec::release_raw() {
  clear_has_raw();
  if (raw_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = raw_;
    raw_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void JobSpec::set_allocated_raw(::std::string* raw) {
  if (raw_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete raw_;
  }
  if (raw) {
    set_has_raw();
    raw_ = raw;
  } else {
    clear_has_raw();
    raw_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.JobSpec.raw)
}

// -------------------------------------------------------------------

// JobStatus

// optional string name = 1;
inline bool JobStatus::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JobStatus::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JobStatus::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JobStatus::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& JobStatus::name() const {
  // @@protoc_insertion_point(field_get:dos.JobStatus.name)
  return *name_;
}
inline void JobStatus::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:dos.JobStatus.name)
}
inline void JobStatus::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.JobStatus.name)
}
inline void JobStatus::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.JobStatus.name)
}
inline ::std::string* JobStatus::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.JobStatus.name)
  return name_;
}
inline ::std::string* JobStatus::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void JobStatus::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.JobStatus.name)
}

// optional .dos.JobState state = 2;
inline bool JobStatus::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JobStatus::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JobStatus::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JobStatus::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::dos::JobState JobStatus::state() const {
  // @@protoc_insertion_point(field_get:dos.JobStatus.state)
  return static_cast< ::dos::JobState >(state_);
}
inline void JobStatus::set_state(::dos::JobState value) {
  assert(::dos::JobState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:dos.JobStatus.state)
}

// optional string user_name = 3;
inline bool JobStatus::has_user_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JobStatus::set_has_user_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JobStatus::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JobStatus::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& JobStatus::user_name() const {
  // @@protoc_insertion_point(field_get:dos.JobStatus.user_name)
  return *user_name_;
}
inline void JobStatus::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set:dos.JobStatus.user_name)
}
inline void JobStatus::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.JobStatus.user_name)
}
inline void JobStatus::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.JobStatus.user_name)
}
inline ::std::string* JobStatus::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.JobStatus.user_name)
  return user_name_;
}
inline ::std::string* JobStatus::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void JobStatus::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.JobStatus.user_name)
}

// optional int64 ctime = 4;
inline bool JobStatus::has_ctime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JobStatus::set_has_ctime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JobStatus::clear_has_ctime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JobStatus::clear_ctime() {
  ctime_ = GOOGLE_LONGLONG(0);
  clear_has_ctime();
}
inline ::google::protobuf::int64 JobStatus::ctime() const {
  // @@protoc_insertion_point(field_get:dos.JobStatus.ctime)
  return ctime_;
}
inline void JobStatus::set_ctime(::google::protobuf::int64 value) {
  set_has_ctime();
  ctime_ = value;
  // @@protoc_insertion_point(field_set:dos.JobStatus.ctime)
}

// optional int64 utime = 5;
inline bool JobStatus::has_utime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void JobStatus::set_has_utime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void JobStatus::clear_has_utime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void JobStatus::clear_utime() {
  utime_ = GOOGLE_LONGLONG(0);
  clear_has_utime();
}
inline ::google::protobuf::int64 JobStatus::utime() const {
  // @@protoc_insertion_point(field_get:dos.JobStatus.utime)
  return utime_;
}
inline void JobStatus::set_utime(::google::protobuf::int64 value) {
  set_has_utime();
  utime_ = value;
  // @@protoc_insertion_point(field_set:dos.JobStatus.utime)
}

// optional .dos.JobSpec desc = 6;
inline bool JobStatus::has_desc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void JobStatus::set_has_desc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void JobStatus::clear_has_desc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void JobStatus::clear_desc() {
  if (desc_ != NULL) desc_->::dos::JobSpec::Clear();
  clear_has_desc();
}
inline const ::dos::JobSpec& JobStatus::desc() const {
  // @@protoc_insertion_point(field_get:dos.JobStatus.desc)
  return desc_ != NULL ? *desc_ : *default_instance_->desc_;
}
inline ::dos::JobSpec* JobStatus::mutable_desc() {
  set_has_desc();
  if (desc_ == NULL) desc_ = new ::dos::JobSpec;
  // @@protoc_insertion_point(field_mutable:dos.JobStatus.desc)
  return desc_;
}
inline ::dos::JobSpec* JobStatus::release_desc() {
  clear_has_desc();
  ::dos::JobSpec* temp = desc_;
  desc_ = NULL;
  return temp;
}
inline void JobStatus::set_allocated_desc(::dos::JobSpec* desc) {
  delete desc_;
  desc_ = desc;
  if (desc) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
  // @@protoc_insertion_point(field_set_allocated:dos.JobStatus.desc)
}

// -------------------------------------------------------------------

// PodLog

// optional string name = 1;
inline bool PodLog::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PodLog::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PodLog::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PodLog::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PodLog::name() const {
  // @@protoc_insertion_point(field_get:dos.PodLog.name)
  return *name_;
}
inline void PodLog::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:dos.PodLog.name)
}
inline void PodLog::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.PodLog.name)
}
inline void PodLog::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.PodLog.name)
}
inline ::std::string* PodLog::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.PodLog.name)
  return name_;
}
inline ::std::string* PodLog::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PodLog::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.PodLog.name)
}

// optional .dos.PodState state_from = 2;
inline bool PodLog::has_state_from() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PodLog::set_has_state_from() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PodLog::clear_has_state_from() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PodLog::clear_state_from() {
  state_from_ = 0;
  clear_has_state_from();
}
inline ::dos::PodState PodLog::state_from() const {
  // @@protoc_insertion_point(field_get:dos.PodLog.state_from)
  return static_cast< ::dos::PodState >(state_from_);
}
inline void PodLog::set_state_from(::dos::PodState value) {
  assert(::dos::PodState_IsValid(value));
  set_has_state_from();
  state_from_ = value;
  // @@protoc_insertion_point(field_set:dos.PodLog.state_from)
}

// optional .dos.PodState state_to = 3;
inline bool PodLog::has_state_to() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PodLog::set_has_state_to() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PodLog::clear_has_state_to() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PodLog::clear_state_to() {
  state_to_ = 0;
  clear_has_state_to();
}
inline ::dos::PodState PodLog::state_to() const {
  // @@protoc_insertion_point(field_get:dos.PodLog.state_to)
  return static_cast< ::dos::PodState >(state_to_);
}
inline void PodLog::set_state_to(::dos::PodState value) {
  assert(::dos::PodState_IsValid(value));
  set_has_state_to();
  state_to_ = value;
  // @@protoc_insertion_point(field_set:dos.PodLog.state_to)
}

// optional int64 time = 4;
inline bool PodLog::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PodLog::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PodLog::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PodLog::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 PodLog::time() const {
  // @@protoc_insertion_point(field_get:dos.PodLog.time)
  return time_;
}
inline void PodLog::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:dos.PodLog.time)
}

// optional string msg = 5;
inline bool PodLog::has_msg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PodLog::set_has_msg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PodLog::clear_has_msg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PodLog::clear_msg() {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& PodLog::msg() const {
  // @@protoc_insertion_point(field_get:dos.PodLog.msg)
  return *msg_;
}
inline void PodLog::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set:dos.PodLog.msg)
}
inline void PodLog::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.PodLog.msg)
}
inline void PodLog::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.PodLog.msg)
}
inline ::std::string* PodLog::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.PodLog.msg)
  return msg_;
}
inline ::std::string* PodLog::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PodLog::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.PodLog.msg)
}

// -------------------------------------------------------------------

// PodStatus

// optional string name = 1;
inline bool PodStatus::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PodStatus::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PodStatus::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PodStatus::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PodStatus::name() const {
  // @@protoc_insertion_point(field_get:dos.PodStatus.name)
  return *name_;
}
inline void PodStatus::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:dos.PodStatus.name)
}
inline void PodStatus::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.PodStatus.name)
}
inline void PodStatus::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.PodStatus.name)
}
inline ::std::string* PodStatus::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.PodStatus.name)
  return name_;
}
inline ::std::string* PodStatus::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PodStatus::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.PodStatus.name)
}

// repeated .dos.ContainerStatus cstatus = 2;
inline int PodStatus::cstatus_size() const {
  return cstatus_.size();
}
inline void PodStatus::clear_cstatus() {
  cstatus_.Clear();
}
inline const ::dos::ContainerStatus& PodStatus::cstatus(int index) const {
  // @@protoc_insertion_point(field_get:dos.PodStatus.cstatus)
  return cstatus_.Get(index);
}
inline ::dos::ContainerStatus* PodStatus::mutable_cstatus(int index) {
  // @@protoc_insertion_point(field_mutable:dos.PodStatus.cstatus)
  return cstatus_.Mutable(index);
}
inline ::dos::ContainerStatus* PodStatus::add_cstatus() {
  // @@protoc_insertion_point(field_add:dos.PodStatus.cstatus)
  return cstatus_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dos::ContainerStatus >&
PodStatus::cstatus() const {
  // @@protoc_insertion_point(field_list:dos.PodStatus.cstatus)
  return cstatus_;
}
inline ::google::protobuf::RepeatedPtrField< ::dos::ContainerStatus >*
PodStatus::mutable_cstatus() {
  // @@protoc_insertion_point(field_mutable_list:dos.PodStatus.cstatus)
  return &cstatus_;
}

// optional .dos.PodSpec desc = 3;
inline bool PodStatus::has_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PodStatus::set_has_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PodStatus::clear_has_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PodStatus::clear_desc() {
  if (desc_ != NULL) desc_->::dos::PodSpec::Clear();
  clear_has_desc();
}
inline const ::dos::PodSpec& PodStatus::desc() const {
  // @@protoc_insertion_point(field_get:dos.PodStatus.desc)
  return desc_ != NULL ? *desc_ : *default_instance_->desc_;
}
inline ::dos::PodSpec* PodStatus::mutable_desc() {
  set_has_desc();
  if (desc_ == NULL) desc_ = new ::dos::PodSpec;
  // @@protoc_insertion_point(field_mutable:dos.PodStatus.desc)
  return desc_;
}
inline ::dos::PodSpec* PodStatus::release_desc() {
  clear_has_desc();
  ::dos::PodSpec* temp = desc_;
  desc_ = NULL;
  return temp;
}
inline void PodStatus::set_allocated_desc(::dos::PodSpec* desc) {
  delete desc_;
  desc_ = desc;
  if (desc) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
  // @@protoc_insertion_point(field_set_allocated:dos.PodStatus.desc)
}

// optional .dos.PodSchedStage stage = 4;
inline bool PodStatus::has_stage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PodStatus::set_has_stage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PodStatus::clear_has_stage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PodStatus::clear_stage() {
  stage_ = 0;
  clear_has_stage();
}
inline ::dos::PodSchedStage PodStatus::stage() const {
  // @@protoc_insertion_point(field_get:dos.PodStatus.stage)
  return static_cast< ::dos::PodSchedStage >(stage_);
}
inline void PodStatus::set_stage(::dos::PodSchedStage value) {
  assert(::dos::PodSchedStage_IsValid(value));
  set_has_stage();
  stage_ = value;
  // @@protoc_insertion_point(field_set:dos.PodStatus.stage)
}

// optional .dos.PodState state = 5;
inline bool PodStatus::has_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PodStatus::set_has_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PodStatus::clear_has_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PodStatus::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::dos::PodState PodStatus::state() const {
  // @@protoc_insertion_point(field_get:dos.PodStatus.state)
  return static_cast< ::dos::PodState >(state_);
}
inline void PodStatus::set_state(::dos::PodState value) {
  assert(::dos::PodState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:dos.PodStatus.state)
}

// optional int64 sched_time = 6;
inline bool PodStatus::has_sched_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PodStatus::set_has_sched_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PodStatus::clear_has_sched_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PodStatus::clear_sched_time() {
  sched_time_ = GOOGLE_LONGLONG(0);
  clear_has_sched_time();
}
inline ::google::protobuf::int64 PodStatus::sched_time() const {
  // @@protoc_insertion_point(field_get:dos.PodStatus.sched_time)
  return sched_time_;
}
inline void PodStatus::set_sched_time(::google::protobuf::int64 value) {
  set_has_sched_time();
  sched_time_ = value;
  // @@protoc_insertion_point(field_set:dos.PodStatus.sched_time)
}

// optional int64 boot_time = 7;
inline bool PodStatus::has_boot_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PodStatus::set_has_boot_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PodStatus::clear_has_boot_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PodStatus::clear_boot_time() {
  boot_time_ = GOOGLE_LONGLONG(0);
  clear_has_boot_time();
}
inline ::google::protobuf::int64 PodStatus::boot_time() const {
  // @@protoc_insertion_point(field_get:dos.PodStatus.boot_time)
  return boot_time_;
}
inline void PodStatus::set_boot_time(::google::protobuf::int64 value) {
  set_has_boot_time();
  boot_time_ = value;
  // @@protoc_insertion_point(field_set:dos.PodStatus.boot_time)
}

// optional int64 start_pending_time = 8;
inline bool PodStatus::has_start_pending_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PodStatus::set_has_start_pending_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PodStatus::clear_has_start_pending_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PodStatus::clear_start_pending_time() {
  start_pending_time_ = GOOGLE_LONGLONG(0);
  clear_has_start_pending_time();
}
inline ::google::protobuf::int64 PodStatus::start_pending_time() const {
  // @@protoc_insertion_point(field_get:dos.PodStatus.start_pending_time)
  return start_pending_time_;
}
inline void PodStatus::set_start_pending_time(::google::protobuf::int64 value) {
  set_has_start_pending_time();
  start_pending_time_ = value;
  // @@protoc_insertion_point(field_set:dos.PodStatus.start_pending_time)
}

// optional string endpoint = 9;
inline bool PodStatus::has_endpoint() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PodStatus::set_has_endpoint() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PodStatus::clear_has_endpoint() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PodStatus::clear_endpoint() {
  if (endpoint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    endpoint_->clear();
  }
  clear_has_endpoint();
}
inline const ::std::string& PodStatus::endpoint() const {
  // @@protoc_insertion_point(field_get:dos.PodStatus.endpoint)
  return *endpoint_;
}
inline void PodStatus::set_endpoint(const ::std::string& value) {
  set_has_endpoint();
  if (endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    endpoint_ = new ::std::string;
  }
  endpoint_->assign(value);
  // @@protoc_insertion_point(field_set:dos.PodStatus.endpoint)
}
inline void PodStatus::set_endpoint(const char* value) {
  set_has_endpoint();
  if (endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    endpoint_ = new ::std::string;
  }
  endpoint_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.PodStatus.endpoint)
}
inline void PodStatus::set_endpoint(const char* value, size_t size) {
  set_has_endpoint();
  if (endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    endpoint_ = new ::std::string;
  }
  endpoint_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.PodStatus.endpoint)
}
inline ::std::string* PodStatus::mutable_endpoint() {
  set_has_endpoint();
  if (endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    endpoint_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.PodStatus.endpoint)
  return endpoint_;
}
inline ::std::string* PodStatus::release_endpoint() {
  clear_has_endpoint();
  if (endpoint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = endpoint_;
    endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PodStatus::set_allocated_endpoint(::std::string* endpoint) {
  if (endpoint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete endpoint_;
  }
  if (endpoint) {
    set_has_endpoint();
    endpoint_ = endpoint;
  } else {
    clear_has_endpoint();
    endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.PodStatus.endpoint)
}

// optional string job_name = 10;
inline bool PodStatus::has_job_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PodStatus::set_has_job_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PodStatus::clear_has_job_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PodStatus::clear_job_name() {
  if (job_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_name_->clear();
  }
  clear_has_job_name();
}
inline const ::std::string& PodStatus::job_name() const {
  // @@protoc_insertion_point(field_get:dos.PodStatus.job_name)
  return *job_name_;
}
inline void PodStatus::set_job_name(const ::std::string& value) {
  set_has_job_name();
  if (job_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_name_ = new ::std::string;
  }
  job_name_->assign(value);
  // @@protoc_insertion_point(field_set:dos.PodStatus.job_name)
}
inline void PodStatus::set_job_name(const char* value) {
  set_has_job_name();
  if (job_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_name_ = new ::std::string;
  }
  job_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.PodStatus.job_name)
}
inline void PodStatus::set_job_name(const char* value, size_t size) {
  set_has_job_name();
  if (job_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_name_ = new ::std::string;
  }
  job_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.PodStatus.job_name)
}
inline ::std::string* PodStatus::mutable_job_name() {
  set_has_job_name();
  if (job_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.PodStatus.job_name)
  return job_name_;
}
inline ::std::string* PodStatus::release_job_name() {
  clear_has_job_name();
  if (job_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = job_name_;
    job_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PodStatus::set_allocated_job_name(::std::string* job_name) {
  if (job_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete job_name_;
  }
  if (job_name) {
    set_has_job_name();
    job_name_ = job_name;
  } else {
    clear_has_job_name();
    job_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.PodStatus.job_name)
}

// -------------------------------------------------------------------

// NodeStatus

// optional .dos.Resource resource = 1;
inline bool NodeStatus::has_resource() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeStatus::set_has_resource() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeStatus::clear_has_resource() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeStatus::clear_resource() {
  if (resource_ != NULL) resource_->::dos::Resource::Clear();
  clear_has_resource();
}
inline const ::dos::Resource& NodeStatus::resource() const {
  // @@protoc_insertion_point(field_get:dos.NodeStatus.resource)
  return resource_ != NULL ? *resource_ : *default_instance_->resource_;
}
inline ::dos::Resource* NodeStatus::mutable_resource() {
  set_has_resource();
  if (resource_ == NULL) resource_ = new ::dos::Resource;
  // @@protoc_insertion_point(field_mutable:dos.NodeStatus.resource)
  return resource_;
}
inline ::dos::Resource* NodeStatus::release_resource() {
  clear_has_resource();
  ::dos::Resource* temp = resource_;
  resource_ = NULL;
  return temp;
}
inline void NodeStatus::set_allocated_resource(::dos::Resource* resource) {
  delete resource_;
  resource_ = resource;
  if (resource) {
    set_has_resource();
  } else {
    clear_has_resource();
  }
  // @@protoc_insertion_point(field_set_allocated:dos.NodeStatus.resource)
}

// repeated .dos.PodStatus pstatus = 2;
inline int NodeStatus::pstatus_size() const {
  return pstatus_.size();
}
inline void NodeStatus::clear_pstatus() {
  pstatus_.Clear();
}
inline const ::dos::PodStatus& NodeStatus::pstatus(int index) const {
  // @@protoc_insertion_point(field_get:dos.NodeStatus.pstatus)
  return pstatus_.Get(index);
}
inline ::dos::PodStatus* NodeStatus::mutable_pstatus(int index) {
  // @@protoc_insertion_point(field_mutable:dos.NodeStatus.pstatus)
  return pstatus_.Mutable(index);
}
inline ::dos::PodStatus* NodeStatus::add_pstatus() {
  // @@protoc_insertion_point(field_add:dos.NodeStatus.pstatus)
  return pstatus_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dos::PodStatus >&
NodeStatus::pstatus() const {
  // @@protoc_insertion_point(field_list:dos.NodeStatus.pstatus)
  return pstatus_;
}
inline ::google::protobuf::RepeatedPtrField< ::dos::PodStatus >*
NodeStatus::mutable_pstatus() {
  // @@protoc_insertion_point(field_mutable_list:dos.NodeStatus.pstatus)
  return &pstatus_;
}

// optional .dos.NodeState state = 3;
inline bool NodeStatus::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeStatus::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeStatus::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeStatus::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::dos::NodeState NodeStatus::state() const {
  // @@protoc_insertion_point(field_get:dos.NodeStatus.state)
  return static_cast< ::dos::NodeState >(state_);
}
inline void NodeStatus::set_state(::dos::NodeState value) {
  assert(::dos::NodeState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:dos.NodeStatus.state)
}

// optional .dos.NodeMeta meta = 4;
inline bool NodeStatus::has_meta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NodeStatus::set_has_meta() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NodeStatus::clear_has_meta() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NodeStatus::clear_meta() {
  if (meta_ != NULL) meta_->::dos::NodeMeta::Clear();
  clear_has_meta();
}
inline const ::dos::NodeMeta& NodeStatus::meta() const {
  // @@protoc_insertion_point(field_get:dos.NodeStatus.meta)
  return meta_ != NULL ? *meta_ : *default_instance_->meta_;
}
inline ::dos::NodeMeta* NodeStatus::mutable_meta() {
  set_has_meta();
  if (meta_ == NULL) meta_ = new ::dos::NodeMeta;
  // @@protoc_insertion_point(field_mutable:dos.NodeStatus.meta)
  return meta_;
}
inline ::dos::NodeMeta* NodeStatus::release_meta() {
  clear_has_meta();
  ::dos::NodeMeta* temp = meta_;
  meta_ = NULL;
  return temp;
}
inline void NodeStatus::set_allocated_meta(::dos::NodeMeta* meta) {
  delete meta_;
  meta_ = meta;
  if (meta) {
    set_has_meta();
  } else {
    clear_has_meta();
  }
  // @@protoc_insertion_point(field_set_allocated:dos.NodeStatus.meta)
}

// optional int64 task_id = 5;
inline bool NodeStatus::has_task_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NodeStatus::set_has_task_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NodeStatus::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NodeStatus::clear_task_id() {
  task_id_ = GOOGLE_LONGLONG(0);
  clear_has_task_id();
}
inline ::google::protobuf::int64 NodeStatus::task_id() const {
  // @@protoc_insertion_point(field_get:dos.NodeStatus.task_id)
  return task_id_;
}
inline void NodeStatus::set_task_id(::google::protobuf::int64 value) {
  set_has_task_id();
  task_id_ = value;
  // @@protoc_insertion_point(field_set:dos.NodeStatus.task_id)
}

// optional int32 version = 6;
inline bool NodeStatus::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NodeStatus::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NodeStatus::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NodeStatus::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 NodeStatus::version() const {
  // @@protoc_insertion_point(field_get:dos.NodeStatus.version)
  return version_;
}
inline void NodeStatus::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:dos.NodeStatus.version)
}

// -------------------------------------------------------------------

// ContainerLog

// optional string name = 1;
inline bool ContainerLog::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerLog::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerLog::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerLog::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ContainerLog::name() const {
  // @@protoc_insertion_point(field_get:dos.ContainerLog.name)
  return *name_;
}
inline void ContainerLog::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:dos.ContainerLog.name)
}
inline void ContainerLog::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.ContainerLog.name)
}
inline void ContainerLog::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.ContainerLog.name)
}
inline ::std::string* ContainerLog::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.ContainerLog.name)
  return name_;
}
inline ::std::string* ContainerLog::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContainerLog::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.ContainerLog.name)
}

// optional .dos.ContainerState cfrom = 2;
inline bool ContainerLog::has_cfrom() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerLog::set_has_cfrom() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerLog::clear_has_cfrom() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerLog::clear_cfrom() {
  cfrom_ = 0;
  clear_has_cfrom();
}
inline ::dos::ContainerState ContainerLog::cfrom() const {
  // @@protoc_insertion_point(field_get:dos.ContainerLog.cfrom)
  return static_cast< ::dos::ContainerState >(cfrom_);
}
inline void ContainerLog::set_cfrom(::dos::ContainerState value) {
  assert(::dos::ContainerState_IsValid(value));
  set_has_cfrom();
  cfrom_ = value;
  // @@protoc_insertion_point(field_set:dos.ContainerLog.cfrom)
}

// optional .dos.ContainerState cto = 3;
inline bool ContainerLog::has_cto() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContainerLog::set_has_cto() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContainerLog::clear_has_cto() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContainerLog::clear_cto() {
  cto_ = 0;
  clear_has_cto();
}
inline ::dos::ContainerState ContainerLog::cto() const {
  // @@protoc_insertion_point(field_get:dos.ContainerLog.cto)
  return static_cast< ::dos::ContainerState >(cto_);
}
inline void ContainerLog::set_cto(::dos::ContainerState value) {
  assert(::dos::ContainerState_IsValid(value));
  set_has_cto();
  cto_ = value;
  // @@protoc_insertion_point(field_set:dos.ContainerLog.cto)
}

// optional int64 time = 4;
inline bool ContainerLog::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContainerLog::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContainerLog::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContainerLog::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 ContainerLog::time() const {
  // @@protoc_insertion_point(field_get:dos.ContainerLog.time)
  return time_;
}
inline void ContainerLog::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:dos.ContainerLog.time)
}

// optional string msg = 5;
inline bool ContainerLog::has_msg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ContainerLog::set_has_msg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ContainerLog::clear_has_msg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ContainerLog::clear_msg() {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& ContainerLog::msg() const {
  // @@protoc_insertion_point(field_get:dos.ContainerLog.msg)
  return *msg_;
}
inline void ContainerLog::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set:dos.ContainerLog.msg)
}
inline void ContainerLog::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.ContainerLog.msg)
}
inline void ContainerLog::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.ContainerLog.msg)
}
inline ::std::string* ContainerLog::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.ContainerLog.msg)
  return msg_;
}
inline ::std::string* ContainerLog::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContainerLog::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.ContainerLog.msg)
}

// -------------------------------------------------------------------

// ContainerStatus

// optional string name = 1;
inline bool ContainerStatus::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerStatus::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerStatus::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerStatus::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ContainerStatus::name() const {
  // @@protoc_insertion_point(field_get:dos.ContainerStatus.name)
  return *name_;
}
inline void ContainerStatus::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:dos.ContainerStatus.name)
}
inline void ContainerStatus::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.ContainerStatus.name)
}
inline void ContainerStatus::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.ContainerStatus.name)
}
inline ::std::string* ContainerStatus::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.ContainerStatus.name)
  return name_;
}
inline ::std::string* ContainerStatus::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContainerStatus::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.ContainerStatus.name)
}

// optional int64 start_time = 2;
inline bool ContainerStatus::has_start_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerStatus::set_has_start_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerStatus::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerStatus::clear_start_time() {
  start_time_ = GOOGLE_LONGLONG(0);
  clear_has_start_time();
}
inline ::google::protobuf::int64 ContainerStatus::start_time() const {
  // @@protoc_insertion_point(field_get:dos.ContainerStatus.start_time)
  return start_time_;
}
inline void ContainerStatus::set_start_time(::google::protobuf::int64 value) {
  set_has_start_time();
  start_time_ = value;
  // @@protoc_insertion_point(field_set:dos.ContainerStatus.start_time)
}

// optional .dos.Resource resource = 3;
inline bool ContainerStatus::has_resource() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContainerStatus::set_has_resource() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContainerStatus::clear_has_resource() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContainerStatus::clear_resource() {
  if (resource_ != NULL) resource_->::dos::Resource::Clear();
  clear_has_resource();
}
inline const ::dos::Resource& ContainerStatus::resource() const {
  // @@protoc_insertion_point(field_get:dos.ContainerStatus.resource)
  return resource_ != NULL ? *resource_ : *default_instance_->resource_;
}
inline ::dos::Resource* ContainerStatus::mutable_resource() {
  set_has_resource();
  if (resource_ == NULL) resource_ = new ::dos::Resource;
  // @@protoc_insertion_point(field_mutable:dos.ContainerStatus.resource)
  return resource_;
}
inline ::dos::Resource* ContainerStatus::release_resource() {
  clear_has_resource();
  ::dos::Resource* temp = resource_;
  resource_ = NULL;
  return temp;
}
inline void ContainerStatus::set_allocated_resource(::dos::Resource* resource) {
  delete resource_;
  resource_ = resource;
  if (resource) {
    set_has_resource();
  } else {
    clear_has_resource();
  }
  // @@protoc_insertion_point(field_set_allocated:dos.ContainerStatus.resource)
}

// optional .dos.ContainerState state = 4;
inline bool ContainerStatus::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContainerStatus::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContainerStatus::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContainerStatus::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::dos::ContainerState ContainerStatus::state() const {
  // @@protoc_insertion_point(field_get:dos.ContainerStatus.state)
  return static_cast< ::dos::ContainerState >(state_);
}
inline void ContainerStatus::set_state(::dos::ContainerState value) {
  assert(::dos::ContainerState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:dos.ContainerStatus.state)
}

// optional int64 boot_time = 6;
inline bool ContainerStatus::has_boot_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ContainerStatus::set_has_boot_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ContainerStatus::clear_has_boot_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ContainerStatus::clear_boot_time() {
  boot_time_ = GOOGLE_LONGLONG(0);
  clear_has_boot_time();
}
inline ::google::protobuf::int64 ContainerStatus::boot_time() const {
  // @@protoc_insertion_point(field_get:dos.ContainerStatus.boot_time)
  return boot_time_;
}
inline void ContainerStatus::set_boot_time(::google::protobuf::int64 value) {
  set_has_boot_time();
  boot_time_ = value;
  // @@protoc_insertion_point(field_set:dos.ContainerStatus.boot_time)
}

// optional .dos.Container spec = 7;
inline bool ContainerStatus::has_spec() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ContainerStatus::set_has_spec() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ContainerStatus::clear_has_spec() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ContainerStatus::clear_spec() {
  if (spec_ != NULL) spec_->::dos::Container::Clear();
  clear_has_spec();
}
inline const ::dos::Container& ContainerStatus::spec() const {
  // @@protoc_insertion_point(field_get:dos.ContainerStatus.spec)
  return spec_ != NULL ? *spec_ : *default_instance_->spec_;
}
inline ::dos::Container* ContainerStatus::mutable_spec() {
  set_has_spec();
  if (spec_ == NULL) spec_ = new ::dos::Container;
  // @@protoc_insertion_point(field_mutable:dos.ContainerStatus.spec)
  return spec_;
}
inline ::dos::Container* ContainerStatus::release_spec() {
  clear_has_spec();
  ::dos::Container* temp = spec_;
  spec_ = NULL;
  return temp;
}
inline void ContainerStatus::set_allocated_spec(::dos::Container* spec) {
  delete spec_;
  spec_ = spec;
  if (spec) {
    set_has_spec();
  } else {
    clear_has_spec();
  }
  // @@protoc_insertion_point(field_set_allocated:dos.ContainerStatus.spec)
}

// optional int64 last_update = 8;
inline bool ContainerStatus::has_last_update() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ContainerStatus::set_has_last_update() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ContainerStatus::clear_has_last_update() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ContainerStatus::clear_last_update() {
  last_update_ = GOOGLE_LONGLONG(0);
  clear_has_last_update();
}
inline ::google::protobuf::int64 ContainerStatus::last_update() const {
  // @@protoc_insertion_point(field_get:dos.ContainerStatus.last_update)
  return last_update_;
}
inline void ContainerStatus::set_last_update(::google::protobuf::int64 value) {
  set_has_last_update();
  last_update_ = value;
  // @@protoc_insertion_point(field_set:dos.ContainerStatus.last_update)
}

// optional int64 restart_count = 9;
inline bool ContainerStatus::has_restart_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ContainerStatus::set_has_restart_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ContainerStatus::clear_has_restart_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ContainerStatus::clear_restart_count() {
  restart_count_ = GOOGLE_LONGLONG(0);
  clear_has_restart_count();
}
inline ::google::protobuf::int64 ContainerStatus::restart_count() const {
  // @@protoc_insertion_point(field_get:dos.ContainerStatus.restart_count)
  return restart_count_;
}
inline void ContainerStatus::set_restart_count(::google::protobuf::int64 value) {
  set_has_restart_count();
  restart_count_ = value;
  // @@protoc_insertion_point(field_set:dos.ContainerStatus.restart_count)
}

// optional string node_addr = 10;
inline bool ContainerStatus::has_node_addr() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ContainerStatus::set_has_node_addr() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ContainerStatus::clear_has_node_addr() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ContainerStatus::clear_node_addr() {
  if (node_addr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_addr_->clear();
  }
  clear_has_node_addr();
}
inline const ::std::string& ContainerStatus::node_addr() const {
  // @@protoc_insertion_point(field_get:dos.ContainerStatus.node_addr)
  return *node_addr_;
}
inline void ContainerStatus::set_node_addr(const ::std::string& value) {
  set_has_node_addr();
  if (node_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_addr_ = new ::std::string;
  }
  node_addr_->assign(value);
  // @@protoc_insertion_point(field_set:dos.ContainerStatus.node_addr)
}
inline void ContainerStatus::set_node_addr(const char* value) {
  set_has_node_addr();
  if (node_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_addr_ = new ::std::string;
  }
  node_addr_->assign(value);
  // @@protoc_insertion_point(field_set_char:dos.ContainerStatus.node_addr)
}
inline void ContainerStatus::set_node_addr(const char* value, size_t size) {
  set_has_node_addr();
  if (node_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_addr_ = new ::std::string;
  }
  node_addr_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dos.ContainerStatus.node_addr)
}
inline ::std::string* ContainerStatus::mutable_node_addr() {
  set_has_node_addr();
  if (node_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_addr_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dos.ContainerStatus.node_addr)
  return node_addr_;
}
inline ::std::string* ContainerStatus::release_node_addr() {
  clear_has_node_addr();
  if (node_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_addr_;
    node_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContainerStatus::set_allocated_node_addr(::std::string* node_addr) {
  if (node_addr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_addr_;
  }
  if (node_addr) {
    set_has_node_addr();
    node_addr_ = node_addr;
  } else {
    clear_has_node_addr();
    node_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dos.ContainerStatus.node_addr)
}

// optional .dos.HealthState health_state = 11;
inline bool ContainerStatus::has_health_state() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ContainerStatus::set_has_health_state() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ContainerStatus::clear_has_health_state() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ContainerStatus::clear_health_state() {
  health_state_ = 0;
  clear_has_health_state();
}
inline ::dos::HealthState ContainerStatus::health_state() const {
  // @@protoc_insertion_point(field_get:dos.ContainerStatus.health_state)
  return static_cast< ::dos::HealthState >(health_state_);
}
inline void ContainerStatus::set_health_state(::dos::HealthState value) {
  assert(::dos::HealthState_IsValid(value));
  set_has_health_state();
  health_state_ = value;
  // @@protoc_insertion_point(field_set:dos.ContainerStatus.health_state)
}

// optional .dos.Resource lowest = 12;
inline bool ContainerStatus::has_lowest() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ContainerStatus::set_has_lowest() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ContainerStatus::clear_has_lowest() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ContainerStatus::clear_lowest() {
  if (lowest_ != NULL) lowest_->::dos::Resource::Clear();
  clear_has_lowest();
}
inline const ::dos::Resource& ContainerStatus::lowest() const {
  // @@protoc_insertion_point(field_get:dos.ContainerStatus.lowest)
  return lowest_ != NULL ? *lowest_ : *default_instance_->lowest_;
}
inline ::dos::Resource* ContainerStatus::mutable_lowest() {
  set_has_lowest();
  if (lowest_ == NULL) lowest_ = new ::dos::Resource;
  // @@protoc_insertion_point(field_mutable:dos.ContainerStatus.lowest)
  return lowest_;
}
inline ::dos::Resource* ContainerStatus::release_lowest() {
  clear_has_lowest();
  ::dos::Resource* temp = lowest_;
  lowest_ = NULL;
  return temp;
}
inline void ContainerStatus::set_allocated_lowest(::dos::Resource* lowest) {
  delete lowest_;
  lowest_ = lowest;
  if (lowest) {
    set_has_lowest();
  } else {
    clear_has_lowest();
  }
  // @@protoc_insertion_point(field_set_allocated:dos.ContainerStatus.lowest)
}

// optional .dos.Resource highest = 13;
inline bool ContainerStatus::has_highest() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ContainerStatus::set_has_highest() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ContainerStatus::clear_has_highest() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ContainerStatus::clear_highest() {
  if (highest_ != NULL) highest_->::dos::Resource::Clear();
  clear_has_highest();
}
inline const ::dos::Resource& ContainerStatus::highest() const {
  // @@protoc_insertion_point(field_get:dos.ContainerStatus.highest)
  return highest_ != NULL ? *highest_ : *default_instance_->highest_;
}
inline ::dos::Resource* ContainerStatus::mutable_highest() {
  set_has_highest();
  if (highest_ == NULL) highest_ = new ::dos::Resource;
  // @@protoc_insertion_point(field_mutable:dos.ContainerStatus.highest)
  return highest_;
}
inline ::dos::Resource* ContainerStatus::release_highest() {
  clear_has_highest();
  ::dos::Resource* temp = highest_;
  highest_ = NULL;
  return temp;
}
inline void ContainerStatus::set_allocated_highest(::dos::Resource* highest) {
  delete highest_;
  highest_ = highest;
  if (highest) {
    set_has_highest();
  } else {
    clear_has_highest();
  }
  // @@protoc_insertion_point(field_set_allocated:dos.ContainerStatus.highest)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace dos

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::dos::RpcStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dos::RpcStatus>() {
  return ::dos::RpcStatus_descriptor();
}
template <> struct is_proto_enum< ::dos::NodeState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dos::NodeState>() {
  return ::dos::NodeState_descriptor();
}
template <> struct is_proto_enum< ::dos::ContainerType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dos::ContainerType>() {
  return ::dos::ContainerType_descriptor();
}
template <> struct is_proto_enum< ::dos::RestartStrategy> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dos::RestartStrategy>() {
  return ::dos::RestartStrategy_descriptor();
}
template <> struct is_proto_enum< ::dos::PodType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dos::PodType>() {
  return ::dos::PodType_descriptor();
}
template <> struct is_proto_enum< ::dos::JobState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dos::JobState>() {
  return ::dos::JobState_descriptor();
}
template <> struct is_proto_enum< ::dos::PodSchedStage> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dos::PodSchedStage>() {
  return ::dos::PodSchedStage_descriptor();
}
template <> struct is_proto_enum< ::dos::PodState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dos::PodState>() {
  return ::dos::PodState_descriptor();
}
template <> struct is_proto_enum< ::dos::ContainerState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dos::ContainerState>() {
  return ::dos::ContainerState_descriptor();
}
template <> struct is_proto_enum< ::dos::HealthState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dos::HealthState>() {
  return ::dos::HealthState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dos_2eproto__INCLUDED
